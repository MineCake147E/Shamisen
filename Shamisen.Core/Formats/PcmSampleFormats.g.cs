#nullable enable
// <auto-generated />
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

namespace Shamisen
{

    /// <summary>
    /// Represents a format of a 16-bit Linear PCM sample source.
    /// </summary>
    public readonly struct Int16LinearPcmSampleFormat : IInterleavedAudioFormat<short>, IEquatable<Int16LinearPcmSampleFormat>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Int16LinearPcmSampleFormat"/> struct.
        /// </summary>
        /// <param name="channels">The channels.</param>
        /// <param name="sampleRate">The sample rate.</param>
        public Int16LinearPcmSampleFormat(int channels, int sampleRate)
        {
            Channels = channels;
            SampleRate = sampleRate;
        }

        /// <summary>
        /// Gets the number of channels.
        /// It does not describe how these loudspeakers of each channels are placed in the room.
        /// </summary>
        /// <value>
        /// The number of channels.
        /// </value>
        public int Channels { get; }

        /// <summary>
        /// Gets the number indicates how many times the audio signal is sampled.
        /// </summary>
        /// <value>
        /// The sample rate.
        /// </value>
        public int SampleRate { get; }

        /// <summary>
        /// Gets the number indicates how many bits are consumed per every single 1-channel sample.
        /// Does not depend on the number of <see cref="Channels"/>.
        /// </summary>
        /// <value>
        /// The bit depth.
        /// </value>
        public int BitDepth => 16;

        /// <summary>
        /// Gets the value indicates how many <see cref="short"/> values are required per whole frame.<br/>
        /// It depends on <see cref="IAudioFormat{TSample}.Channels"/>.
        /// </summary>
        /// <value>
        /// The size of block.
        /// </value>
        public int BlockSize {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => Channels; }

        /// <summary>
        /// Gets the value indicates how many <see cref="short"/>s are required per 1-channel sample.<br/>
        /// Does not depend on the number of <see cref="Channels"/>.<br/>
        /// </summary>
        /// <value>
        /// The size of a frame in <see cref="short"/>s.
        /// </value>
        public int SampleSize {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => 1; }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="obj">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the obj parameter; otherwise, <c>false</c>.</returns>
        public override bool Equals(object? obj)
        {
            return obj is Int16LinearPcmSampleFormat format && Equals(format);
        }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the other parameter; otherwise, <c>false</c>.</returns>
        public bool Equals(Int16LinearPcmSampleFormat other)
        {
            return Channels == other.Channels &&
                SampleRate == other.SampleRate;
        }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the other parameter; otherwise, <c>false</c>.</returns>
        public bool Equals(IAudioFormat<short>? other)
        {
            return !(other is null) && other.BitDepth == BitDepth && other.Channels == Channels && other.SampleRate == SampleRate;
        }

        /// <summary>Returns a hash code for this instance.</summary>
        /// <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        public override int GetHashCode() => HashCode.Combine(Channels, SampleRate);


        /// <summary>
        /// Indicates whether the values of two specified <see cref="Int16LinearPcmSampleFormat"/> objects are equal.
        /// </summary>
        /// <param name="left">The first <see cref="Int16LinearPcmSampleFormat"/> to compare.</param>
        /// <param name="right">The second <see cref="Int16LinearPcmSampleFormat"/> to compare.</param>
        /// <returns>
        ///   <c>true</c> if the value of left is the same as the value of right; otherwise, <c>false</c>.
        /// </returns>
        public static bool operator ==(Int16LinearPcmSampleFormat left, Int16LinearPcmSampleFormat right)
        {
            return left.Equals(right);
        }

        /// <summary>
        /// Indicates whether the values of two specified <see cref="Int16LinearPcmSampleFormat"/> objects are different.
        /// </summary>
        /// <param name="left">The first <see cref="Int16LinearPcmSampleFormat"/> to compare.</param>
        /// <param name="right">The second <see cref="Int16LinearPcmSampleFormat"/> to compare.</param>
        /// <returns>
        ///   <c>true</c> if the value of int1 is not the same as the value of int2; otherwise, <c>false</c>.
        /// </returns>
        public static bool operator !=(Int16LinearPcmSampleFormat left, Int16LinearPcmSampleFormat right)
        {
            return !(left == right);
        }
    }


    /// <summary>
    /// Represents a format of a 24-bit Linear PCM sample source.
    /// </summary>
    public readonly struct Int24LinearPcmSampleFormat : IInterleavedAudioFormat<Int24>, IEquatable<Int24LinearPcmSampleFormat>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Int24LinearPcmSampleFormat"/> struct.
        /// </summary>
        /// <param name="channels">The channels.</param>
        /// <param name="sampleRate">The sample rate.</param>
        public Int24LinearPcmSampleFormat(int channels, int sampleRate)
        {
            Channels = channels;
            SampleRate = sampleRate;
        }

        /// <summary>
        /// Gets the number of channels.
        /// It does not describe how these loudspeakers of each channels are placed in the room.
        /// </summary>
        /// <value>
        /// The number of channels.
        /// </value>
        public int Channels { get; }

        /// <summary>
        /// Gets the number indicates how many times the audio signal is sampled.
        /// </summary>
        /// <value>
        /// The sample rate.
        /// </value>
        public int SampleRate { get; }

        /// <summary>
        /// Gets the number indicates how many bits are consumed per every single 1-channel sample.
        /// Does not depend on the number of <see cref="Channels"/>.
        /// </summary>
        /// <value>
        /// The bit depth.
        /// </value>
        public int BitDepth => 24;

        /// <summary>
        /// Gets the value indicates how many <see cref="Int24"/> values are required per whole frame.<br/>
        /// It depends on <see cref="IAudioFormat{TSample}.Channels"/>.
        /// </summary>
        /// <value>
        /// The size of block.
        /// </value>
        public int BlockSize {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => Channels; }

        /// <summary>
        /// Gets the value indicates how many <see cref="Int24"/>s are required per 1-channel sample.<br/>
        /// Does not depend on the number of <see cref="Channels"/>.<br/>
        /// </summary>
        /// <value>
        /// The size of a frame in <see cref="Int24"/>s.
        /// </value>
        public int SampleSize {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => 1; }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="obj">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the obj parameter; otherwise, <c>false</c>.</returns>
        public override bool Equals(object? obj)
        {
            return obj is Int24LinearPcmSampleFormat format && Equals(format);
        }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the other parameter; otherwise, <c>false</c>.</returns>
        public bool Equals(Int24LinearPcmSampleFormat other)
        {
            return Channels == other.Channels &&
                SampleRate == other.SampleRate;
        }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the other parameter; otherwise, <c>false</c>.</returns>
        public bool Equals(IAudioFormat<Int24>? other)
        {
            return !(other is null) && other.BitDepth == BitDepth && other.Channels == Channels && other.SampleRate == SampleRate;
        }

        /// <summary>Returns a hash code for this instance.</summary>
        /// <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        public override int GetHashCode() => HashCode.Combine(Channels, SampleRate);


        /// <summary>
        /// Indicates whether the values of two specified <see cref="Int24LinearPcmSampleFormat"/> objects are equal.
        /// </summary>
        /// <param name="left">The first <see cref="Int24LinearPcmSampleFormat"/> to compare.</param>
        /// <param name="right">The second <see cref="Int24LinearPcmSampleFormat"/> to compare.</param>
        /// <returns>
        ///   <c>true</c> if the value of left is the same as the value of right; otherwise, <c>false</c>.
        /// </returns>
        public static bool operator ==(Int24LinearPcmSampleFormat left, Int24LinearPcmSampleFormat right)
        {
            return left.Equals(right);
        }

        /// <summary>
        /// Indicates whether the values of two specified <see cref="Int24LinearPcmSampleFormat"/> objects are different.
        /// </summary>
        /// <param name="left">The first <see cref="Int24LinearPcmSampleFormat"/> to compare.</param>
        /// <param name="right">The second <see cref="Int24LinearPcmSampleFormat"/> to compare.</param>
        /// <returns>
        ///   <c>true</c> if the value of int1 is not the same as the value of int2; otherwise, <c>false</c>.
        /// </returns>
        public static bool operator !=(Int24LinearPcmSampleFormat left, Int24LinearPcmSampleFormat right)
        {
            return !(left == right);
        }
    }


    /// <summary>
    /// Represents a format of a 32-bit Linear PCM sample source.
    /// </summary>
    public readonly struct Int32LinearPcmSampleFormat : IInterleavedAudioFormat<int>, IEquatable<Int32LinearPcmSampleFormat>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Int32LinearPcmSampleFormat"/> struct.
        /// </summary>
        /// <param name="channels">The channels.</param>
        /// <param name="sampleRate">The sample rate.</param>
        public Int32LinearPcmSampleFormat(int channels, int sampleRate)
        {
            Channels = channels;
            SampleRate = sampleRate;
        }

        /// <summary>
        /// Gets the number of channels.
        /// It does not describe how these loudspeakers of each channels are placed in the room.
        /// </summary>
        /// <value>
        /// The number of channels.
        /// </value>
        public int Channels { get; }

        /// <summary>
        /// Gets the number indicates how many times the audio signal is sampled.
        /// </summary>
        /// <value>
        /// The sample rate.
        /// </value>
        public int SampleRate { get; }

        /// <summary>
        /// Gets the number indicates how many bits are consumed per every single 1-channel sample.
        /// Does not depend on the number of <see cref="Channels"/>.
        /// </summary>
        /// <value>
        /// The bit depth.
        /// </value>
        public int BitDepth => 32;

        /// <summary>
        /// Gets the value indicates how many <see cref="int"/> values are required per whole frame.<br/>
        /// It depends on <see cref="IAudioFormat{TSample}.Channels"/>.
        /// </summary>
        /// <value>
        /// The size of block.
        /// </value>
        public int BlockSize {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => Channels; }

        /// <summary>
        /// Gets the value indicates how many <see cref="int"/>s are required per 1-channel sample.<br/>
        /// Does not depend on the number of <see cref="Channels"/>.<br/>
        /// </summary>
        /// <value>
        /// The size of a frame in <see cref="int"/>s.
        /// </value>
        public int SampleSize {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => 1; }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="obj">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the obj parameter; otherwise, <c>false</c>.</returns>
        public override bool Equals(object? obj)
        {
            return obj is Int32LinearPcmSampleFormat format && Equals(format);
        }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the other parameter; otherwise, <c>false</c>.</returns>
        public bool Equals(Int32LinearPcmSampleFormat other)
        {
            return Channels == other.Channels &&
                SampleRate == other.SampleRate;
        }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the other parameter; otherwise, <c>false</c>.</returns>
        public bool Equals(IAudioFormat<int>? other)
        {
            return !(other is null) && other.BitDepth == BitDepth && other.Channels == Channels && other.SampleRate == SampleRate;
        }

        /// <summary>Returns a hash code for this instance.</summary>
        /// <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        public override int GetHashCode() => HashCode.Combine(Channels, SampleRate);


        /// <summary>
        /// Indicates whether the values of two specified <see cref="Int32LinearPcmSampleFormat"/> objects are equal.
        /// </summary>
        /// <param name="left">The first <see cref="Int32LinearPcmSampleFormat"/> to compare.</param>
        /// <param name="right">The second <see cref="Int32LinearPcmSampleFormat"/> to compare.</param>
        /// <returns>
        ///   <c>true</c> if the value of left is the same as the value of right; otherwise, <c>false</c>.
        /// </returns>
        public static bool operator ==(Int32LinearPcmSampleFormat left, Int32LinearPcmSampleFormat right)
        {
            return left.Equals(right);
        }

        /// <summary>
        /// Indicates whether the values of two specified <see cref="Int32LinearPcmSampleFormat"/> objects are different.
        /// </summary>
        /// <param name="left">The first <see cref="Int32LinearPcmSampleFormat"/> to compare.</param>
        /// <param name="right">The second <see cref="Int32LinearPcmSampleFormat"/> to compare.</param>
        /// <returns>
        ///   <c>true</c> if the value of int1 is not the same as the value of int2; otherwise, <c>false</c>.
        /// </returns>
        public static bool operator !=(Int32LinearPcmSampleFormat left, Int32LinearPcmSampleFormat right)
        {
            return !(left == right);
        }
    }


    /// <summary>
    /// Represents a format of a 64-bit Linear PCM sample source.
    /// </summary>
    public readonly struct Int64LinearPcmSampleFormat : IInterleavedAudioFormat<long>, IEquatable<Int64LinearPcmSampleFormat>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Int64LinearPcmSampleFormat"/> struct.
        /// </summary>
        /// <param name="channels">The channels.</param>
        /// <param name="sampleRate">The sample rate.</param>
        public Int64LinearPcmSampleFormat(int channels, int sampleRate)
        {
            Channels = channels;
            SampleRate = sampleRate;
        }

        /// <summary>
        /// Gets the number of channels.
        /// It does not describe how these loudspeakers of each channels are placed in the room.
        /// </summary>
        /// <value>
        /// The number of channels.
        /// </value>
        public int Channels { get; }

        /// <summary>
        /// Gets the number indicates how many times the audio signal is sampled.
        /// </summary>
        /// <value>
        /// The sample rate.
        /// </value>
        public int SampleRate { get; }

        /// <summary>
        /// Gets the number indicates how many bits are consumed per every single 1-channel sample.
        /// Does not depend on the number of <see cref="Channels"/>.
        /// </summary>
        /// <value>
        /// The bit depth.
        /// </value>
        public int BitDepth => 64;

        /// <summary>
        /// Gets the value indicates how many <see cref="long"/> values are required per whole frame.<br/>
        /// It depends on <see cref="IAudioFormat{TSample}.Channels"/>.
        /// </summary>
        /// <value>
        /// The size of block.
        /// </value>
        public int BlockSize {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => Channels; }

        /// <summary>
        /// Gets the value indicates how many <see cref="long"/>s are required per 1-channel sample.<br/>
        /// Does not depend on the number of <see cref="Channels"/>.<br/>
        /// </summary>
        /// <value>
        /// The size of a frame in <see cref="long"/>s.
        /// </value>
        public int SampleSize {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => 1; }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="obj">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the obj parameter; otherwise, <c>false</c>.</returns>
        public override bool Equals(object? obj)
        {
            return obj is Int64LinearPcmSampleFormat format && Equals(format);
        }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the other parameter; otherwise, <c>false</c>.</returns>
        public bool Equals(Int64LinearPcmSampleFormat other)
        {
            return Channels == other.Channels &&
                SampleRate == other.SampleRate;
        }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the other parameter; otherwise, <c>false</c>.</returns>
        public bool Equals(IAudioFormat<long>? other)
        {
            return !(other is null) && other.BitDepth == BitDepth && other.Channels == Channels && other.SampleRate == SampleRate;
        }

        /// <summary>Returns a hash code for this instance.</summary>
        /// <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        public override int GetHashCode() => HashCode.Combine(Channels, SampleRate);


        /// <summary>
        /// Indicates whether the values of two specified <see cref="Int64LinearPcmSampleFormat"/> objects are equal.
        /// </summary>
        /// <param name="left">The first <see cref="Int64LinearPcmSampleFormat"/> to compare.</param>
        /// <param name="right">The second <see cref="Int64LinearPcmSampleFormat"/> to compare.</param>
        /// <returns>
        ///   <c>true</c> if the value of left is the same as the value of right; otherwise, <c>false</c>.
        /// </returns>
        public static bool operator ==(Int64LinearPcmSampleFormat left, Int64LinearPcmSampleFormat right)
        {
            return left.Equals(right);
        }

        /// <summary>
        /// Indicates whether the values of two specified <see cref="Int64LinearPcmSampleFormat"/> objects are different.
        /// </summary>
        /// <param name="left">The first <see cref="Int64LinearPcmSampleFormat"/> to compare.</param>
        /// <param name="right">The second <see cref="Int64LinearPcmSampleFormat"/> to compare.</param>
        /// <returns>
        ///   <c>true</c> if the value of int1 is not the same as the value of int2; otherwise, <c>false</c>.
        /// </returns>
        public static bool operator !=(Int64LinearPcmSampleFormat left, Int64LinearPcmSampleFormat right)
        {
            return !(left == right);
        }
    }


    /// <summary>
    /// Represents a format of an 8-bit Linear PCM sample source.
    /// </summary>
    public readonly struct OffsetSByteLinearPcmSampleFormat : IInterleavedAudioFormat<OffsetSByte>, IEquatable<OffsetSByteLinearPcmSampleFormat>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OffsetSByteLinearPcmSampleFormat"/> struct.
        /// </summary>
        /// <param name="channels">The channels.</param>
        /// <param name="sampleRate">The sample rate.</param>
        public OffsetSByteLinearPcmSampleFormat(int channels, int sampleRate)
        {
            Channels = channels;
            SampleRate = sampleRate;
        }

        /// <summary>
        /// Gets the number of channels.
        /// It does not describe how these loudspeakers of each channels are placed in the room.
        /// </summary>
        /// <value>
        /// The number of channels.
        /// </value>
        public int Channels { get; }

        /// <summary>
        /// Gets the number indicates how many times the audio signal is sampled.
        /// </summary>
        /// <value>
        /// The sample rate.
        /// </value>
        public int SampleRate { get; }

        /// <summary>
        /// Gets the number indicates how many bits are consumed per every single 1-channel sample.
        /// Does not depend on the number of <see cref="Channels"/>.
        /// </summary>
        /// <value>
        /// The bit depth.
        /// </value>
        public int BitDepth => 8;

        /// <summary>
        /// Gets the value indicates how many <see cref="OffsetSByte"/> values are required per whole frame.<br/>
        /// It depends on <see cref="IAudioFormat{TSample}.Channels"/>.
        /// </summary>
        /// <value>
        /// The size of block.
        /// </value>
        public int BlockSize {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => Channels; }

        /// <summary>
        /// Gets the value indicates how many <see cref="OffsetSByte"/>s are required per 1-channel sample.<br/>
        /// Does not depend on the number of <see cref="Channels"/>.<br/>
        /// </summary>
        /// <value>
        /// The size of a frame in <see cref="OffsetSByte"/>s.
        /// </value>
        public int SampleSize {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => 1; }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="obj">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the obj parameter; otherwise, <c>false</c>.</returns>
        public override bool Equals(object? obj)
        {
            return obj is OffsetSByteLinearPcmSampleFormat format && Equals(format);
        }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the other parameter; otherwise, <c>false</c>.</returns>
        public bool Equals(OffsetSByteLinearPcmSampleFormat other)
        {
            return Channels == other.Channels &&
                SampleRate == other.SampleRate;
        }

        /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        ///   <c>true</c> if the current object is equal to the other parameter; otherwise, <c>false</c>.</returns>
        public bool Equals(IAudioFormat<OffsetSByte>? other)
        {
            return !(other is null) && other.BitDepth == BitDepth && other.Channels == Channels && other.SampleRate == SampleRate;
        }

        /// <summary>Returns a hash code for this instance.</summary>
        /// <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        public override int GetHashCode() => HashCode.Combine(Channels, SampleRate);


        /// <summary>
        /// Indicates whether the values of two specified <see cref="OffsetSByteLinearPcmSampleFormat"/> objects are equal.
        /// </summary>
        /// <param name="left">The first <see cref="OffsetSByteLinearPcmSampleFormat"/> to compare.</param>
        /// <param name="right">The second <see cref="OffsetSByteLinearPcmSampleFormat"/> to compare.</param>
        /// <returns>
        ///   <c>true</c> if the value of left is the same as the value of right; otherwise, <c>false</c>.
        /// </returns>
        public static bool operator ==(OffsetSByteLinearPcmSampleFormat left, OffsetSByteLinearPcmSampleFormat right)
        {
            return left.Equals(right);
        }

        /// <summary>
        /// Indicates whether the values of two specified <see cref="OffsetSByteLinearPcmSampleFormat"/> objects are different.
        /// </summary>
        /// <param name="left">The first <see cref="OffsetSByteLinearPcmSampleFormat"/> to compare.</param>
        /// <param name="right">The second <see cref="OffsetSByteLinearPcmSampleFormat"/> to compare.</param>
        /// <returns>
        ///   <c>true</c> if the value of int1 is not the same as the value of int2; otherwise, <c>false</c>.
        /// </returns>
        public static bool operator !=(OffsetSByteLinearPcmSampleFormat left, OffsetSByteLinearPcmSampleFormat right)
        {
            return !(left == right);
        }
    }

}
