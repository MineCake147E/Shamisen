// <!--<auto-generated />-->
using System;
using System.Collections.Generic;
using System.Text;
using static System.Runtime.InteropServices.MemoryMarshal;
using System.Numerics;
using System.Runtime.CompilerServices;
using Shamisen.Filters;
using Shamisen.Formats;
using Shamisen.Utils;

namespace Shamisen.Conversion.Resampling.Sample
{
    public sealed partial class SplineResampler
    {
        private const int RemSampleOffset = 4;

        #region GetFunc
        [MethodImpl(OptimizationUtils.InlineAndOptimizeIfPossible)]
        private unsafe ResampleFunc GetFuncCachedDirect(in UnifiedResampleArgs args)
        {
            var channels = args.Channels;
            if (channels == Vector<float>.Count) //SIMD Optimized Multi-Channel Audio Resampling
            {
                return new(&ResampleCachedDirectVectorFitChannelsStandard);
            } else {
                switch (channels) {
                    case 1: //Monaural
                        return GetFuncCachedDirectMonaural(args);
                        #region SIMD Optimized Multi-Channel Audio Resampling
                    case 2:
                        return GetFuncCachedDirect2Channels(args);
                    case 3:
                        return GetFuncCachedDirect3Channels(args);
                    case 4:
                        return GetFuncCachedDirect4Channels(args);

                        #endregion SIMD Optimized Multi-Channel Audio Resampling

                    default:
                        return GetFuncCachedDirectGeneric(args);
                }
            }
        }

        [MethodImpl(OptimizationUtils.InlineAndOptimizeIfPossible)]
        private unsafe ResampleFunc GetFuncCachedWrappedOdd(in UnifiedResampleArgs args)
        {
            var channels = args.Channels;
            if (channels == Vector<float>.Count) //SIMD Optimized Multi-Channel Audio Resampling
            {
                return new(&ResampleCachedWrappedOddVectorFitChannelsStandard);
            } else {
                switch (channels) {
                    case 1: //Monaural
                        return new(&ResampleCachedWrappedOddMonauralStandard);

                        #region SIMD Optimized Multi-Channel Audio Resampling
                    case 2 :
                        return new(&ResampleCachedWrappedOdd2ChannelsStandard);
                    case 3 :
                        return new(&ResampleCachedWrappedOdd3ChannelsStandard);
                    case 4 :
                        return new(&ResampleCachedWrappedOdd4ChannelsStandard);

                        #endregion SIMD Optimized Multi-Channel Audio Resampling

                    default:
                        return GetFuncCachedWrappedOddGeneric(args);
                }
            }
        }

        [MethodImpl(OptimizationUtils.InlineAndOptimizeIfPossible)]
        private unsafe ResampleFunc GetFuncCachedWrappedEven(in UnifiedResampleArgs args)
        {
            var channels = args.Channels;
            if (channels == Vector<float>.Count) //SIMD Optimized Multi-Channel Audio Resampling
            {
                return new(&ResampleCachedWrappedEvenVectorFitChannelsStandard);
            } else {
                switch (channels) {
                    case 1: //Monaural
                        return new(&ResampleCachedWrappedEvenMonauralStandard);
                        #region SIMD Optimized Multi-Channel Audio Resampling
                    case 2 :
                        return new(&ResampleCachedWrappedEven2ChannelsStandard);
                    case 3 :
                        return new(&ResampleCachedWrappedEven3ChannelsStandard);
                    case 4 :
                        return new(&ResampleCachedWrappedEven4ChannelsStandard);
                        #endregion SIMD Optimized Multi-Channel Audio Resampling
                    default:
                        return GetFuncCachedWrappedEvenGeneric(args);
                }
            }
        }


        [MethodImpl(OptimizationUtils.InlineAndOptimizeIfPossible)]
        private unsafe ResampleFunc GetFuncDirect(in UnifiedResampleArgs args)
        {
            var channels = args.Channels;
            if (channels == Vector<float>.Count) //SIMD Optimized Multi-Channel Audio Resampling
            {
                return new(&ResampleDirectVectorFitStandard);
            } else {
                switch (channels) {
                    case 1: //Monaural
                        return new(&ResampleDirectMonauralStandard);
                        #region SIMD Optimized Multi-Channel Audio Resampling
                    case 2 :
                        return new(&ResampleDirect2ChannelsStandard);
                    case 3 :
                        return new(&ResampleDirect3ChannelsStandard);
                    case 4 :
                        return new(&ResampleDirect4ChannelsStandard);

                        #endregion SIMD Optimized Multi-Channel Audio Resampling

                    default:
                        return GetFuncDirectGeneric(args);
                }
            }
        }

        #endregion

        #region CachedDirect

        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        internal static ResampleResult ResampleCachedDirect2ChannelsStandard(UnifiedResampleArgs args, Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan)
        //(Span<float> buffer, Span<float> srcBuffer, ref Vector4 coeffPtr, ref int x, int ram, int acc, int facc, ref int rci)
        {
            nint isx = 0;
            const nint Size = 4 * 2;
            nint psx = (nint)args.ConversionGradient * 16;
            nint nrci = args.RearrangedCoeffsIndex * 16;
            nint nram = (nint)args.RateMul * 16;
            nint nacc = (nint)args.GradientIncrement * 16;
            nint nfacc = (nint)args.IndexIncrement * Size;
            ref var coeffPtr = ref GetReference(cspan);
            ref var vBuffer = ref GetReference(buffer);
            ref var vSrcBuffer = ref Unsafe.As<float, Vector2>(ref GetReference(srcBuffer));
            nint i;
            nint length = buffer.Length;
            if (nfacc > 0)
            {
                nint olen = length - 1;
                for (i = 0; i < olen; i += 2)
                {
                    var cutmullCoeffs = Unsafe.AddByteOffset(ref coeffPtr, nrci);
                    nrci += 16;
                    psx += nacc;
                    bool j = nrci < nram;
                    nint z = Unsafe.As<bool, byte>(ref j);
                    bool h = psx >= nram;
                    nint y = Unsafe.As<bool, byte>(ref h);
                    z = -z;
                    y = -y;
                    Unsafe.As<float, Vector2>(ref Unsafe.Add(ref vBuffer, i)) = VectorUtils.FastDotMultiple2Channels(ref Unsafe.AddByteOffset(ref vSrcBuffer, isx), cutmullCoeffs);
                    nrci &= z;
                    psx -= y & nram;
                    isx += nfacc;
                    isx += y & Size;
                }
            }
            else
            {
                nint olen = length - 1;
                for (i = 0; i < olen; i += 2)
                {
                    var cutmullCoeffs = Unsafe.AddByteOffset(ref coeffPtr, nrci);
                    nrci += 16;
                    psx += nacc;
                    bool j = nrci < nram;
                    nint z = Unsafe.As<bool, byte>(ref j);
                    bool h = psx >= nram;
                    nint y = Unsafe.As<bool, byte>(ref h);
                    z = -z;
                    y = -y;
                    Unsafe.As<float, Vector2>(ref Unsafe.Add(ref vBuffer, i)) = VectorUtils.FastDotMultiple2Channels(ref Unsafe.AddByteOffset(ref vSrcBuffer, isx), cutmullCoeffs);
                    nrci &= z;
                    psx -= y & nram;
                    isx += y & Size;
                }
            }
            return new((int)((nuint)isx / (nuint)Size), (int)((nuint)psx / 16), (int)((nuint)nrci / 16));
        }

        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        internal static ResampleResult ResampleCachedDirect3ChannelsStandard(UnifiedResampleArgs args, Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan)
        //(Span<float> buffer, Span<float> srcBuffer, ref Vector4 coeffPtr, ref int x, int ram, int acc, int facc, ref int rci)
        {
            nint isx = 0;
            const nint Size = 4 * 3;
            nint psx = (nint)args.ConversionGradient * 16;
            nint nrci = args.RearrangedCoeffsIndex * 16;
            nint nram = (nint)args.RateMul * 16;
            nint nacc = (nint)args.GradientIncrement * 16;
            nint nfacc = (nint)args.IndexIncrement * Size;
            ref var coeffPtr = ref GetReference(cspan);
            ref var vBuffer = ref GetReference(buffer);
            ref var vSrcBuffer = ref Unsafe.As<float, Vector3>(ref GetReference(srcBuffer));
            nint i;
            nint length = buffer.Length;
            if (nfacc > 0)
            {
                nint olen = length - 2;
                for (i = 0; i < olen; i += 3)
                {
                    var cutmullCoeffs = Unsafe.AddByteOffset(ref coeffPtr, nrci);
                    nrci += 16;
                    psx += nacc;
                    bool j = nrci < nram;
                    nint z = Unsafe.As<bool, byte>(ref j);
                    bool h = psx >= nram;
                    nint y = Unsafe.As<bool, byte>(ref h);
                    z = -z;
                    y = -y;
                    Unsafe.As<float, Vector3>(ref Unsafe.Add(ref vBuffer, i)) = VectorUtils.FastDotMultiple3Channels(ref Unsafe.AddByteOffset(ref vSrcBuffer, isx), cutmullCoeffs);
                    nrci &= z;
                    psx -= y & nram;
                    isx += nfacc;
                    isx += y & Size;
                }
            }
            else
            {
                nint olen = length - 2;
                for (i = 0; i < olen; i += 3)
                {
                    var cutmullCoeffs = Unsafe.AddByteOffset(ref coeffPtr, nrci);
                    nrci += 16;
                    psx += nacc;
                    bool j = nrci < nram;
                    nint z = Unsafe.As<bool, byte>(ref j);
                    bool h = psx >= nram;
                    nint y = Unsafe.As<bool, byte>(ref h);
                    z = -z;
                    y = -y;
                    Unsafe.As<float, Vector3>(ref Unsafe.Add(ref vBuffer, i)) = VectorUtils.FastDotMultiple3Channels(ref Unsafe.AddByteOffset(ref vSrcBuffer, isx), cutmullCoeffs);
                    nrci &= z;
                    psx -= y & nram;
                    isx += y & Size;
                }
            }
            return new((int)((nuint)isx / (nuint)Size), (int)((nuint)psx / 16), (int)((nuint)nrci / 16));
        }

        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        internal static ResampleResult ResampleCachedDirect4ChannelsStandard(UnifiedResampleArgs args, Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan)
        //(Span<float> buffer, Span<float> srcBuffer, ref Vector4 coeffPtr, ref int x, int ram, int acc, int facc, ref int rci)
        {
            nint isx = 0;
            const nint Size = 4 * 4;
            nint psx = (nint)args.ConversionGradient * 16;
            nint nrci = args.RearrangedCoeffsIndex * 16;
            nint nram = (nint)args.RateMul * 16;
            nint nacc = (nint)args.GradientIncrement * 16;
            nint nfacc = (nint)args.IndexIncrement * Size;
            ref var coeffPtr = ref GetReference(cspan);
            ref var vBuffer = ref GetReference(buffer);
            ref var vSrcBuffer = ref Unsafe.As<float, Vector4>(ref GetReference(srcBuffer));
            nint i;
            nint length = buffer.Length;
            if (nfacc > 0)
            {
                nint olen = length - 3;
                for (i = 0; i < olen; i += 4)
                {
                    var cutmullCoeffs = Unsafe.AddByteOffset(ref coeffPtr, nrci);
                    nrci += 16;
                    psx += nacc;
                    bool j = nrci < nram;
                    nint z = Unsafe.As<bool, byte>(ref j);
                    bool h = psx >= nram;
                    nint y = Unsafe.As<bool, byte>(ref h);
                    z = -z;
                    y = -y;
                    Unsafe.As<float, Vector4>(ref Unsafe.Add(ref vBuffer, i)) = VectorUtils.FastDotMultiple4Channels(ref Unsafe.AddByteOffset(ref vSrcBuffer, isx), cutmullCoeffs);
                    nrci &= z;
                    psx -= y & nram;
                    isx += nfacc;
                    isx += y & Size;
                }
            }
            else
            {
                nint olen = length - 3;
                for (i = 0; i < olen; i += 4)
                {
                    var cutmullCoeffs = Unsafe.AddByteOffset(ref coeffPtr, nrci);
                    nrci += 16;
                    psx += nacc;
                    bool j = nrci < nram;
                    nint z = Unsafe.As<bool, byte>(ref j);
                    bool h = psx >= nram;
                    nint y = Unsafe.As<bool, byte>(ref h);
                    z = -z;
                    y = -y;
                    Unsafe.As<float, Vector4>(ref Unsafe.Add(ref vBuffer, i)) = VectorUtils.FastDotMultiple4Channels(ref Unsafe.AddByteOffset(ref vSrcBuffer, isx), cutmullCoeffs);
                    nrci &= z;
                    psx -= y & nram;
                    isx += y & Size;
                }
            }
            return new((int)((nuint)isx / (nuint)Size), (int)((nuint)psx / 16), (int)((nuint)nrci / 16));
        }

        #endregion

        #region CachedWrappedOdd

        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        internal static ResampleResult ResampleCachedWrappedOdd2ChannelsStandard(UnifiedResampleArgs args, Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan)
        {
            int psx = args.ConversionGradient;
            int rec = args.RearrangedCoeffsIndex;
            int ram = args.RateMul;
            int red = args.RearrangedCoeffsDirection;
            int acc = args.GradientIncrement;
            int facc = args.IndexIncrement;
            int isx = 0;
            ref var coeffPtr = ref GetReference(cspan);
            int rew = cspan.Length;
            ref var rsi = ref Unsafe.As<float, Vector2>(ref GetReference(srcBuffer));
            ref var rdi = ref Unsafe.As<float, Vector2>(ref GetReference(buffer));
            nint i = 0;
            nint length = buffer.Length / 2;
            if (red < 0)
            {
                var olen = MathI.Min(length, rec);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple2Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec == 0)
                {
                    red = 1;
                }
            }
            while (i < length)
            {
                var olen = MathI.Min(length, i + (rew - rec));
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = Unsafe.Add(ref coeffPtr, rec++);
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple2Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec >= rew)
                {
                    red = -1;
                    rec--;
                }
                olen = MathI.Min(length, i + rec);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple2Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec == 0)
                {
                    red = 1;
                }
            }
            return ((int)isx, (int)psx, (int)rec, (int)red);
        }

        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        internal static ResampleResult ResampleCachedWrappedOdd3ChannelsStandard(UnifiedResampleArgs args, Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan)
        {
            int psx = args.ConversionGradient;
            int rec = args.RearrangedCoeffsIndex;
            int ram = args.RateMul;
            int red = args.RearrangedCoeffsDirection;
            int acc = args.GradientIncrement;
            int facc = args.IndexIncrement;
            int isx = 0;
            ref var coeffPtr = ref GetReference(cspan);
            int rew = cspan.Length;
            ref var rsi = ref Unsafe.As<float, Vector3>(ref GetReference(srcBuffer));
            ref var rdi = ref Unsafe.As<float, Vector3>(ref GetReference(buffer));
            nint i = 0;
            nint length = buffer.Length / 3;
            if (red < 0)
            {
                var olen = MathI.Min(length, rec);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple3Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec == 0)
                {
                    red = 1;
                }
            }
            while (i < length)
            {
                var olen = MathI.Min(length, i + (rew - rec));
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = Unsafe.Add(ref coeffPtr, rec++);
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple3Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec >= rew)
                {
                    red = -1;
                    rec--;
                }
                olen = MathI.Min(length, i + rec);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple3Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec == 0)
                {
                    red = 1;
                }
            }
            return ((int)isx, (int)psx, (int)rec, (int)red);
        }

        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        internal static ResampleResult ResampleCachedWrappedOdd4ChannelsStandard(UnifiedResampleArgs args, Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan)
        {
            int psx = args.ConversionGradient;
            int rec = args.RearrangedCoeffsIndex;
            int ram = args.RateMul;
            int red = args.RearrangedCoeffsDirection;
            int acc = args.GradientIncrement;
            int facc = args.IndexIncrement;
            int isx = 0;
            ref var coeffPtr = ref GetReference(cspan);
            int rew = cspan.Length;
            ref var rsi = ref Unsafe.As<float, Vector4>(ref GetReference(srcBuffer));
            ref var rdi = ref Unsafe.As<float, Vector4>(ref GetReference(buffer));
            nint i = 0;
            nint length = buffer.Length / 4;
            if (red < 0)
            {
                var olen = MathI.Min(length, rec);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple4Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec == 0)
                {
                    red = 1;
                }
            }
            while (i < length)
            {
                var olen = MathI.Min(length, i + (rew - rec));
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = Unsafe.Add(ref coeffPtr, rec++);
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple4Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec >= rew)
                {
                    red = -1;
                    rec--;
                }
                olen = MathI.Min(length, i + rec);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple4Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec == 0)
                {
                    red = 1;
                }
            }
            return ((int)isx, (int)psx, (int)rec, (int)red);
        }


        #endregion

        #region CachedWrappedEven
        
        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        internal static ResampleResult ResampleCachedWrappedEven2ChannelsStandard(UnifiedResampleArgs args, Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan)
        //(Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan, int x, int ram, int acc, int facc, int rearrangedCoeffsIndex, int rearrangedCoeffsDirection)
        {
            int psx = args.ConversionGradient;
            int rec = args.RearrangedCoeffsIndex;
            int ram = args.RateMul;
            int red = args.RearrangedCoeffsDirection;
            int acc = args.GradientIncrement;
            int facc = args.IndexIncrement;
            int isx = 0;
            ref var coeffPtr = ref GetReference(cspan);
            int rew = cspan.Length;
            var vBuffer = Cast<float, Vector2>(buffer);
            var vSrcBuffer = Cast<float, Vector2>(srcBuffer);
            nint i = 0, length=vBuffer.Length;
            ref var rsi = ref GetReference(vSrcBuffer);
            ref var rdi = ref GetReference(vBuffer);
            if (red < 0)
            {
                var olen = MathI.Min(length, rec + 1);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple2Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec < 0)
                {
                    red = 1;
                    rec = 0;
                }
            }
            while (i < length)
            {
                var olen = MathI.Min(length, i - rec + rew);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = Unsafe.Add(ref coeffPtr, rec++);
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple2Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec >= rew)
                {
                    red = -1;
                    rec--;
                }
                olen = MathI.Min(length, i + rec + 1);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple2Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec < 0)
                {
                    red = 1;
                    rec = 0;
                }
            }
            return ((int)isx, (int)psx, (int)rec, (int)red);
        }

        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        internal static ResampleResult ResampleCachedWrappedEven3ChannelsStandard(UnifiedResampleArgs args, Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan)
        //(Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan, int x, int ram, int acc, int facc, int rearrangedCoeffsIndex, int rearrangedCoeffsDirection)
        {
            int psx = args.ConversionGradient;
            int rec = args.RearrangedCoeffsIndex;
            int ram = args.RateMul;
            int red = args.RearrangedCoeffsDirection;
            int acc = args.GradientIncrement;
            int facc = args.IndexIncrement;
            int isx = 0;
            ref var coeffPtr = ref GetReference(cspan);
            int rew = cspan.Length;
            var vBuffer = Cast<float, Vector3>(buffer);
            var vSrcBuffer = Cast<float, Vector3>(srcBuffer);
            nint i = 0, length=vBuffer.Length;
            ref var rsi = ref GetReference(vSrcBuffer);
            ref var rdi = ref GetReference(vBuffer);
            if (red < 0)
            {
                var olen = MathI.Min(length, rec + 1);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple3Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec < 0)
                {
                    red = 1;
                    rec = 0;
                }
            }
            while (i < length)
            {
                var olen = MathI.Min(length, i - rec + rew);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = Unsafe.Add(ref coeffPtr, rec++);
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple3Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec >= rew)
                {
                    red = -1;
                    rec--;
                }
                olen = MathI.Min(length, i + rec + 1);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple3Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec < 0)
                {
                    red = 1;
                    rec = 0;
                }
            }
            return ((int)isx, (int)psx, (int)rec, (int)red);
        }

        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        internal static ResampleResult ResampleCachedWrappedEven4ChannelsStandard(UnifiedResampleArgs args, Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan)
        //(Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan, int x, int ram, int acc, int facc, int rearrangedCoeffsIndex, int rearrangedCoeffsDirection)
        {
            int psx = args.ConversionGradient;
            int rec = args.RearrangedCoeffsIndex;
            int ram = args.RateMul;
            int red = args.RearrangedCoeffsDirection;
            int acc = args.GradientIncrement;
            int facc = args.IndexIncrement;
            int isx = 0;
            ref var coeffPtr = ref GetReference(cspan);
            int rew = cspan.Length;
            var vBuffer = Cast<float, Vector4>(buffer);
            var vSrcBuffer = Cast<float, Vector4>(srcBuffer);
            nint i = 0, length=vBuffer.Length;
            ref var rsi = ref GetReference(vSrcBuffer);
            ref var rdi = ref GetReference(vBuffer);
            if (red < 0)
            {
                var olen = MathI.Min(length, rec + 1);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple4Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec < 0)
                {
                    red = 1;
                    rec = 0;
                }
            }
            while (i < length)
            {
                var olen = MathI.Min(length, i - rec + rew);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = Unsafe.Add(ref coeffPtr, rec++);
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple4Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec >= rew)
                {
                    red = -1;
                    rec--;
                }
                olen = MathI.Min(length, i + rec + 1);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple4Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec < 0)
                {
                    red = 1;
                    rec = 0;
                }
            }
            return ((int)isx, (int)psx, (int)rec, (int)red);
        }


        #endregion

        #region Direct

        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        internal static ResampleResult ResampleDirect2ChannelsStandard(UnifiedResampleArgs args, Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan)
        {
            nint isx = 0;
            nint psx = args.ConversionGradient;
            nint spsx = psx;
            nint nram = args.RateMul;
            nint nacc = args.GradientIncrement;
            nint facc = args.IndexIncrement;
            float rmi = args.RateMulInverse;
            var vBuffer = Cast<float, Vector2>(buffer);
            var vSrcBuffer = Cast<float, Vector2>(srcBuffer);
            nint i = 0, length=vBuffer.Length;
            ref var rsi = ref GetReference(vSrcBuffer);
            ref var rdi = ref GetReference(vBuffer);
            Vector4 c0 = C0, c1 = C1, c2 = C2, c3 = C3;
            Vector4 x1 = default, x2 = default, x3 = default;
            Vector4 y0 = default, y1 = default, y2 = default;
            for (int j = 0; j < 4; j++)
            {
                var nx3 = new Vector4(spsx * rmi);
                spsx += nacc;
                bool h2 = spsx >= nram;
                nint g2 = Unsafe.As<bool, byte>(ref h2);
                y0 = y1 * x1;
                y0 += c3;
                y1 = y2 * x2;
                y1 += c2;
                y2 = c0 * x3;
                y2 += c1;
                spsx -= -g2 & nram;
                x1 = x2;
                x2 = x3;
                x3 = nx3;
            }
            for (; i < length; i++)
            {
                psx += nacc;
                bool h = psx >= nram;
                nint g = Unsafe.As<bool, byte>(ref h);
                Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple2Channels(ref Unsafe.Add(ref rsi, isx), y0);
                isx += g;
                isx += facc;
                var nx3 = new Vector4(spsx * rmi);
                spsx += nacc;
                bool h2 = spsx >= nram;
                nint g2 = Unsafe.As<bool, byte>(ref h2);
                y0 = y1 * x1;
                y0 += c3;
                y1 = y2 * x2;
                y1 += c2;
                y2 = c0 * x3;
                y2 += c1;
                psx -= -g & nram;
                spsx -= -g2 & nram;
                x1 = x2;
                x2 = x3;
                x3 = nx3;
            }
            return new((int)isx, (int)psx);
        }

        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        internal static ResampleResult ResampleDirect3ChannelsStandard(UnifiedResampleArgs args, Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan)
        {
            nint isx = 0;
            nint psx = args.ConversionGradient;
            nint spsx = psx;
            nint nram = args.RateMul;
            nint nacc = args.GradientIncrement;
            nint facc = args.IndexIncrement;
            float rmi = args.RateMulInverse;
            var vBuffer = Cast<float, Vector3>(buffer);
            var vSrcBuffer = Cast<float, Vector3>(srcBuffer);
            nint i = 0, length=vBuffer.Length;
            ref var rsi = ref GetReference(vSrcBuffer);
            ref var rdi = ref GetReference(vBuffer);
            Vector4 c0 = C0, c1 = C1, c2 = C2, c3 = C3;
            Vector4 x1 = default, x2 = default, x3 = default;
            Vector4 y0 = default, y1 = default, y2 = default;
            for (int j = 0; j < 4; j++)
            {
                var nx3 = new Vector4(spsx * rmi);
                spsx += nacc;
                bool h2 = spsx >= nram;
                nint g2 = Unsafe.As<bool, byte>(ref h2);
                y0 = y1 * x1;
                y0 += c3;
                y1 = y2 * x2;
                y1 += c2;
                y2 = c0 * x3;
                y2 += c1;
                spsx -= -g2 & nram;
                x1 = x2;
                x2 = x3;
                x3 = nx3;
            }
            for (; i < length; i++)
            {
                psx += nacc;
                bool h = psx >= nram;
                nint g = Unsafe.As<bool, byte>(ref h);
                Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple3Channels(ref Unsafe.Add(ref rsi, isx), y0);
                isx += g;
                isx += facc;
                var nx3 = new Vector4(spsx * rmi);
                spsx += nacc;
                bool h2 = spsx >= nram;
                nint g2 = Unsafe.As<bool, byte>(ref h2);
                y0 = y1 * x1;
                y0 += c3;
                y1 = y2 * x2;
                y1 += c2;
                y2 = c0 * x3;
                y2 += c1;
                psx -= -g & nram;
                spsx -= -g2 & nram;
                x1 = x2;
                x2 = x3;
                x3 = nx3;
            }
            return new((int)isx, (int)psx);
        }

        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        internal static ResampleResult ResampleDirect4ChannelsStandard(UnifiedResampleArgs args, Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan)
        {
            nint isx = 0;
            nint psx = args.ConversionGradient;
            nint spsx = psx;
            nint nram = args.RateMul;
            nint nacc = args.GradientIncrement;
            nint facc = args.IndexIncrement;
            float rmi = args.RateMulInverse;
            var vBuffer = Cast<float, Vector4>(buffer);
            var vSrcBuffer = Cast<float, Vector4>(srcBuffer);
            nint i = 0, length=vBuffer.Length;
            ref var rsi = ref GetReference(vSrcBuffer);
            ref var rdi = ref GetReference(vBuffer);
            Vector4 c0 = C0, c1 = C1, c2 = C2, c3 = C3;
            Vector4 x1 = default, x2 = default, x3 = default;
            Vector4 y0 = default, y1 = default, y2 = default;
            for (int j = 0; j < 4; j++)
            {
                var nx3 = new Vector4(spsx * rmi);
                spsx += nacc;
                bool h2 = spsx >= nram;
                nint g2 = Unsafe.As<bool, byte>(ref h2);
                y0 = y1 * x1;
                y0 += c3;
                y1 = y2 * x2;
                y1 += c2;
                y2 = c0 * x3;
                y2 += c1;
                spsx -= -g2 & nram;
                x1 = x2;
                x2 = x3;
                x3 = nx3;
            }
            for (; i < length; i++)
            {
                psx += nacc;
                bool h = psx >= nram;
                nint g = Unsafe.As<bool, byte>(ref h);
                Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple4Channels(ref Unsafe.Add(ref rsi, isx), y0);
                isx += g;
                isx += facc;
                var nx3 = new Vector4(spsx * rmi);
                spsx += nacc;
                bool h2 = spsx >= nram;
                nint g2 = Unsafe.As<bool, byte>(ref h2);
                y0 = y1 * x1;
                y0 += c3;
                y1 = y2 * x2;
                y1 += c2;
                y2 = c0 * x3;
                y2 += c1;
                psx -= -g & nram;
                spsx -= -g2 & nram;
                x1 = x2;
                x2 = x3;
                x3 = nx3;
            }
            return new((int)isx, (int)psx);
        }

        #endregion
    }
}
