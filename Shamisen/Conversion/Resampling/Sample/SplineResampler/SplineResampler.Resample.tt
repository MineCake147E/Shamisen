<#@ template debug = "false" hostspecific = "false" language = "C#"#>
<#@ assembly name = "System.Core"#>
<#@ import namespace = "System.Linq"#>
<#@ import namespace = "System.Text"#>
<#@ import namespace = "System.Collections.Generic"#>
<#@ output extension = ".g.cs"#>
<#    var channelsAndTypes = new [] {(2, "Vector2"), (3, "Vector3"), (4, "Vector4")};#>
<#var attributes = new [] {(2, "Vector2", "Stereo"), (3, "Vector3", "Triple"), (4, "Vector4", "Quadruple")};#>
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Text;
using static System.Runtime.InteropServices.MemoryMarshal;
using System.Numerics;
using System.Runtime.CompilerServices;
using Shamisen.Filters;
using Shamisen.Formats;
using Shamisen.Utils;

namespace Shamisen.Conversion.Resampling.Sample
{
    public sealed partial class SplineResampler
    {
        private const int RemSampleOffset = 4;

        #region CachedDirect
        [MethodImpl(OptimizationUtils.InlineAndOptimizeIfPossible)]
        private int ResampleCachedDirect (Span<float> buffer, int channels, Span<float> srcBuffer) {
            var cspan = preCalculatedCatmullRomCoefficients.AsSpan();
            ref var coeffPtr = ref GetReference(cspan);
            int outputSamplePosition = 0;
            int inputSampleIndex = 0, x = conversionGradient;
            int ram = RateMul;
            int acc = GradientIncrement;
            int facc = IndexIncrement;
            int rci = rearrangedCoeffsIndex;
            if (channels == Vector<float>.Count) //SIMD Optimized Multi-Channel Audio Resampling
            {
                inputSampleIndex = ResampleCachedDirectVectorFitChannelsStandard(buffer, srcBuffer, ref coeffPtr, ref x, ram, acc, facc, ref rci);
            } else {
                switch (channels) {
                    case 1: //Monaural
                        inputSampleIndex = ResampleCachedDirectMonaural(buffer, srcBuffer, ref coeffPtr, ref x, ram, acc, facc, ref rci);
                        break;
                        #region SIMD Optimized Multi-Channel Audio Resampling
<#foreach ((var ch, var type) in channelsAndTypes) {#>
                    case <#= ch#>:
                        inputSampleIndex = ResampleCachedDirect<#=ch#>Channels(buffer, srcBuffer, ref coeffPtr, ref x, ram, acc, facc, ref rci);
                        break;
<#}#>

                        #endregion SIMD Optimized Multi-Channel Audio Resampling

                    default:
                        inputSampleIndex = ResampleCachedDirectGeneric(buffer, srcBuffer, ref coeffPtr, channels, ref x, ram, acc, facc, ref rci);
                        break;
                }
            }
            rearrangedCoeffsIndex = rci;
            conversionGradient = x;
            return inputSampleIndex;
        }

<#foreach ((var ch, var type) in channelsAndTypes) {#>
        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        private static int ResampleCachedDirect<#=ch#>ChannelsStandard(Span<float> buffer, Span<float> srcBuffer, ref Vector4 coeffPtr, ref int x, int ram, int acc, int facc, ref int rci)
        {
            nint isx = 0;
            const nint Size = 4 * <#=ch#>;
            nint psx = (nint)x * 16;
            nint nram = (nint)ram * 16;
            nint nacc = (nint)acc * 16;
            nint nfacc = (nint)facc * Size;
            nint nrci = rci * 16;
            ref var vBuffer = ref GetReference(buffer);
            ref var vSrcBuffer = ref Unsafe.As<float, <#=type#>>(ref GetReference(srcBuffer));
            nint i;
            nint length = buffer.Length;
            if (nfacc > 0)
            {
                nint olen = length - <#=ch - 1#>;
                for (i = 0; i < olen; i += <#=ch#>)
                {
                    var cutmullCoeffs = Unsafe.AddByteOffset(ref coeffPtr, nrci);
                    nrci += 16;
                    psx += nacc;
                    bool j = nrci < nram;
                    nint z = Unsafe.As<bool, byte>(ref j);
                    bool h = psx >= nram;
                    nint y = Unsafe.As<bool, byte>(ref h);
                    z = -z;
                    y = -y;
                    Unsafe.As<float, <#=type#>>(ref Unsafe.Add(ref vBuffer, i)) = VectorUtils.FastDotMultiple<#=ch#>Channels
                                                                                    (ref Unsafe.AddByteOffset(ref vSrcBuffer, isx), cutmullCoeffs);
                    nrci &= z;
                    psx -= y & nram;
                    isx += nfacc;
                    isx += y & Size;
                }
            }
            else
            {
                nint olen = length - <#=ch - 1#>;
                for (i = 0; i < olen; i += <#=ch#>)
                {
                    var cutmullCoeffs = Unsafe.AddByteOffset(ref coeffPtr, nrci);
                    nrci += 16;
                    psx += nacc;
                    bool j = nrci < nram;
                    nint z = Unsafe.As<bool, byte>(ref j);
                    bool h = psx >= nram;
                    nint y = Unsafe.As<bool, byte>(ref h);
                    z = -z;
                    y = -y;
                    Unsafe.As<float, <#=type#>>(ref Unsafe.Add(ref vBuffer, i)) = VectorUtils.FastDotMultiple<#=ch#>Channels
                                                                                    (ref Unsafe.AddByteOffset(ref vSrcBuffer, isx), cutmullCoeffs);
                    nrci &= z;
                    psx -= y & nram;
                    isx += y & Size;
                }
            }
            rci = (int)((nuint)nrci / 16);
            x = (int)((nuint)psx / 16);
            return (int)((nuint)isx / (nuint)Size);
        }

<#}#>
        #endregion

        #region CachedWrappedOdd
        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        private int ResampleCachedWrappedOdd (Span<float> buffer, int channels, Span<float> srcBuffer)
        {
            var cspan = preCalculatedCatmullRomCoefficients.AsSpan();
            ref var coeffPtr = ref GetReference(cspan);
            int outputSamplePosition = 0;
            int inputSampleIndex = 0, x = conversionGradient;
            int ram = RateMul;
            int acc = GradientIncrement;
            int facc = IndexIncrement;
            int rec = rearrangedCoeffsIndex;
            int red = rearrangedCoeffsDirection;
            int rew = cspan.Length;
            if (channels == Vector<float>.Count) //SIMD Optimized Multi-Channel Audio Resampling
            {
                (inputSampleIndex, conversionGradient, rearrangedCoeffsIndex, rearrangedCoeffsDirection) = ResampleCachedWrappedOddVectorFitChannelsStandard(buffer, srcBuffer, cspan, x, ram, acc, facc, rec, red);
                return inputSampleIndex;
            } else {
                switch (channels) {
                    case 1: //Monaural
                        (inputSampleIndex, conversionGradient, rearrangedCoeffsIndex, rearrangedCoeffsDirection) = ResampleCachedWrappedOddMonauralStandard(buffer, srcBuffer, cspan, x, ram, acc, facc, rec, red);
                        return inputSampleIndex;

                        #region SIMD Optimized Multi-Channel Audio Resampling
<#foreach ((var ch, var type) in channelsAndTypes) {#>
                    case <#= ch#> :
                        (inputSampleIndex, conversionGradient, rearrangedCoeffsIndex, rearrangedCoeffsDirection) = ResampleCachedWrappedOdd<#=ch#>ChannelsStandard(buffer, srcBuffer, cspan, new CachedResampleArgs(x, ram, acc, facc), rec, red);
                        return inputSampleIndex;
<#}#>

                        #endregion SIMD Optimized Multi-Channel Audio Resampling

                    default:

                        #region Channels that is not SIMD optimized

                        {
                            unsafe {
                                fixed (float * srcBufPtr = srcBuffer) {
                                    int i = 0;
                                    var length = buffer.Length - channels + 1;
                                    if(red < 0)
                                    {
                                        var olen = MathI.Min(length, rec * channels);
                                        for (; i < olen; i += channels) {
                                            var cache = srcBufPtr + inputSampleIndex * channels;
                                            var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                                            for (int ch = 0; ch < channels; ch++) {
                                                ref var destSample = ref buffer[i + ch]; //Persist the reference in order to reduce boundary checks.
                                                var values = new Vector4(
                                                    cache[ch], cache[channels + ch], cache[channels * 2 + ch], cache[channels * 3 + ch]);
                                                destSample = VectorUtils.FastDotProduct(values, cutmullCoeffs);
                                            }
                                            x += acc;
                                            inputSampleIndex += facc;
                                            bool h = x >= ram;
                                            int y = Unsafe.As<bool, byte>(ref h);
                                            inputSampleIndex += y;
                                            x -= -y & ram;
                                            outputSamplePosition++;
                                        }
                                        if (rec == 0)
                                        {
                                            red = 1;
                                        }
                                    }
                                    while(i < buffer.Length - channels + 1)
                                    {
                                        var olen = MathI.Min(length, i + channels * (rew - rec));
                                        for (; i < olen; i += channels) {
                                            var cache = srcBufPtr + inputSampleIndex * channels;
                                            var cutmullCoeffs = Unsafe.Add(ref coeffPtr, rec++);
                                            for (int ch = 0; ch < channels; ch++) {
                                                ref var destSample = ref buffer[i + ch]; //Persist the reference in order to reduce boundary checks.
                                                var values = new Vector4(
                                                    cache[ch], cache[channels + ch], cache[channels * 2 + ch], cache[channels * 3 + ch]);
                                                destSample = VectorUtils.FastDotProduct(values, cutmullCoeffs);
                                            }
                                            x += acc;
                                            inputSampleIndex += facc;
                                            bool h = x >= ram;
                                            int y = Unsafe.As<bool, byte>(ref h);
                                            inputSampleIndex += y;
                                            x -= -y & ram;
                                            outputSamplePosition++;
                                        }
                                        if (rec >= rew)
                                        {
                                            red = -1;
                                            rec--;
                                        }
                                        olen = MathI.Min(length, i + channels * rec);
                                        for (; i < buffer.Length - channels + 1 && rec > 0; i += channels) {
                                            var cache = srcBufPtr + inputSampleIndex * channels;
                                            var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                                            for (int ch = 0; ch < channels; ch++) {
                                                ref var destSample = ref buffer[i + ch]; //Persist the reference in order to reduce boundary checks.
                                                var values = new Vector4(
                                                    cache[ch], cache[channels + ch], cache[channels * 2 + ch], cache[channels * 3 + ch]);
                                                destSample = VectorUtils.FastDotProduct(values, cutmullCoeffs);
                                            }
                                            x += acc;
                                            inputSampleIndex += facc;
                                            bool h = x >= ram;
                                            int y = Unsafe.As<bool, byte>(ref h);
                                            inputSampleIndex += y;
                                            x -= -y & ram;
                                            outputSamplePosition++;
                                        }
                                        if (rec == 0)
                                        {
                                            red = 1;
                                        }
                                    }
                                }
                            }
                        }

                        #endregion Channels that is not SIMD optimized

                        break;
                }
            }
            rearrangedCoeffsIndex = rec;
            rearrangedCoeffsDirection = red;
            conversionGradient = x;
            return inputSampleIndex;
        }

<#foreach ((var ch, var type) in channelsAndTypes) {#>
        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        private static (int inputSampleIndex, int x, int rearrangedCoeffsIndex, int rearrangedCoeffsDirection) ResampleCachedWrappedOdd<#=ch#>ChannelsStandard
            (Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan, CachedResampleArgs args, int rearrangedCoeffsIndex, int rearrangedCoeffsDirection)
        {
            int ram = args.RateMul;
            int acc = args.GradientIncrement;
            int facc = args.IndexIncrement;
            int isx = 0;
            int psx = args.ConversionGradient;
            ref var coeffPtr = ref GetReference(cspan);
            int rec = rearrangedCoeffsIndex;
            int red = rearrangedCoeffsDirection;
            int rew = cspan.Length;
            ref var rsi = ref Unsafe.As<float, <#= type#>>(ref GetReference(srcBuffer));
            ref var rdi = ref Unsafe.As<float, <#= type#>>(ref GetReference(buffer));
            nint i = 0;
            nint length = buffer.Length / <#=ch#>;
            if (red < 0)
            {
                var olen = MathI.Min(length, rec);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple<#=ch#>Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec == 0)
                {
                    red = 1;
                }
            }
            while (i < length)
            {
                var olen = MathI.Min(length, i + (rew - rec));
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = Unsafe.Add(ref coeffPtr, rec++);
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple<#=ch#>Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec >= rew)
                {
                    red = -1;
                    rec--;
                }
                olen = MathI.Min(length, i + rec);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple<#=ch#>Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec == 0)
                {
                    red = 1;
                }
            }
            return (isx, psx, rec, red);
        }

<#}#>

        #endregion

        #region CachedWrappedEven
        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        private int ResampleCachedWrappedEven(Span<float> buffer, int channels, Span<float> srcBuffer)
        {
            var cspan = preCalculatedCatmullRomCoefficients.AsSpan();
            ref var coeffPtr = ref GetReference(cspan);
            int outputSamplePosition = 0;
            int inputSampleIndex = 0, x = conversionGradient;
            int ram = RateMul;
            int acc = GradientIncrement;
            int facc = IndexIncrement;
            int rec = rearrangedCoeffsIndex;
            int red = rearrangedCoeffsDirection;
            int rew = cspan.Length;
            if (channels == Vector<float>.Count) //SIMD Optimized Multi-Channel Audio Resampling
            {
                (inputSampleIndex, conversionGradient, rearrangedCoeffsIndex, rearrangedCoeffsDirection) = ResampleCachedWrappedEvenVectorFitChannelsStandard(buffer, srcBuffer, cspan, x, ram, acc, facc, rec, red);
                return inputSampleIndex;
            } else {
                switch (channels) {
                    case 1: //Monaural
                        (inputSampleIndex, conversionGradient, rearrangedCoeffsIndex, rearrangedCoeffsDirection) = ResampleCachedWrappedEvenMonauralStandard(buffer, srcBuffer, cspan, x, ram, acc, facc, rec, red);
                        return inputSampleIndex;
                        #region SIMD Optimized Multi-Channel Audio Resampling
<#foreach ((var ch, var type) in channelsAndTypes) {#>
                    case <#= ch#> :
                        (inputSampleIndex, conversionGradient, rearrangedCoeffsIndex, rearrangedCoeffsDirection) = ResampleCachedWrappedEven<#=ch#>ChannelsStandard(buffer, srcBuffer, cspan, x, ram, acc, facc, rec, red);
                        return inputSampleIndex;
<#}#>
                        #endregion SIMD Optimized Multi-Channel Audio Resampling
                    default:
                        #region Channels that is not SIMD optimized
                        {
                            unsafe {
                                fixed (float * srcBufPtr = srcBuffer) {
                                    int i = 0;
                                    if(red < 0)
                                    {
                                        for (; i < buffer.Length - channels + 1 && rec >= 0; i += channels) {
                                            var cache = srcBufPtr + inputSampleIndex * channels;
                                            var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                                            for (int ch = 0; ch < channels; ch++) {
                                                ref var destSample = ref buffer[i + ch]; //Persist the reference in order to reduce boundary checks.
                                                var values = new Vector4(
                                                    cache[ch], cache[channels + ch], cache[channels * 2 + ch], cache[channels * 3 + ch]);
                                                destSample = VectorUtils.FastDotProduct(values, cutmullCoeffs);
                                            }
                                            x += acc;
                                            inputSampleIndex += facc;
                                            bool h = x >= ram;
                                            int y = Unsafe.As<bool, byte>(ref h);
                                            inputSampleIndex += y;
                                            x -= -y & ram;
                                            outputSamplePosition++;
                                        }
                                        if (rec < 0)
                                        {
                                            red = 1;
                                            rec = 0;
                                        }
                                    }
                                    while(i < buffer.Length - channels + 1)
                                    {
                                        for (; i < buffer.Length - channels + 1 && rec < rew; i += channels) {
                                            var cache = srcBufPtr + inputSampleIndex * channels;
                                            var cutmullCoeffs = Unsafe.Add(ref coeffPtr, rec++);
                                            for (int ch = 0; ch < channels; ch++) {
                                                ref var destSample = ref buffer[i + ch]; //Persist the reference in order to reduce boundary checks.
                                                var values = new Vector4(
                                                    cache[ch], cache[channels + ch], cache[channels * 2 + ch], cache[channels * 3 + ch]);
                                                destSample = VectorUtils.FastDotProduct(values, cutmullCoeffs);
                                            }
                                            x += acc;
                                            inputSampleIndex += facc;
                                            bool h = x >= ram;
                                            int y = Unsafe.As<bool, byte>(ref h);
                                            inputSampleIndex += y;
                                            x -= -y & ram;
                                            outputSamplePosition++;
                                        }
                                        if (rec >= rew)
                                        {
                                            red = -1;
                                            rec--;
                                        }
                                        for (; i < buffer.Length - channels + 1 && rec >= 0; i += channels) {
                                            var cache = srcBufPtr + inputSampleIndex * channels;
                                            var cutmullCoeffs = Unsafe.Add(ref coeffPtr, rec--);
                                            for (int ch = 0; ch < channels; ch++) {
                                                ref var destSample = ref buffer[i + ch]; //Persist the reference in order to reduce boundary checks.
                                                var values = new Vector4(
                                                    cache[ch], cache[channels + ch], cache[channels * 2 + ch], cache[channels * 3 + ch]);
                                                destSample = VectorUtils.FastDotProduct(values, cutmullCoeffs);
                                            }
                                            x += acc;
                                            inputSampleIndex += facc;
                                            bool h = x >= ram;
                                            int y = Unsafe.As<bool, byte>(ref h);
                                            inputSampleIndex += y;
                                            x -= -y & ram;
                                            outputSamplePosition++;
                                        }
                                        if (rec < 0)
                                        {
                                            red = 1;
                                            rec = 0;
                                        }
                                    }
                                }
                            }
                        }

                        #endregion Channels that is not SIMD optimized

                        break;
                }
            }
            rearrangedCoeffsIndex = rec;
            rearrangedCoeffsDirection = red;
            conversionGradient = x;
            return inputSampleIndex;
        }

<#foreach ((var ch, var type) in channelsAndTypes) {#>
        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        private static (int inputSampleIndex, int x, int rearrangedCoeffsIndex, int rearrangedCoeffsDirection) ResampleCachedWrappedEven<#=ch#>ChannelsStandard(Span<float> buffer, Span<float> srcBuffer, Span<Vector4> cspan, int x, int ram, int acc, int facc, int rearrangedCoeffsIndex, int rearrangedCoeffsDirection)
        {
            int isx = 0;
            int psx = x;
            ref var coeffPtr = ref GetReference(cspan);
            int rec = rearrangedCoeffsIndex;
            int red = rearrangedCoeffsDirection;
            int rew = cspan.Length;
            var vBuffer = Cast<float, <#= type#>>(buffer);
            var vSrcBuffer = Cast<float, <#= type#>>(srcBuffer);
            nint i = 0, length=vBuffer.Length;
            ref var rsi = ref GetReference(vSrcBuffer);
            ref var rdi = ref GetReference(vBuffer);
            if (red < 0)
            {
                var olen = MathI.Min(length, rec + 1);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple<#=ch#>Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec < 0)
                {
                    red = 1;
                    rec = 0;
                }
            }
            while (i < length)
            {
                var olen = MathI.Min(length, i - rec + rew);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = Unsafe.Add(ref coeffPtr, rec++);
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple<#=ch#>Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec >= rew)
                {
                    red = -1;
                    rec--;
                }
                olen = MathI.Min(length, i + rec + 1);
                for (; i < olen; i++)
                {
                    var cutmullCoeffs = VectorUtils.ReverseElements(Unsafe.Add(ref coeffPtr, rec--));
                    Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple<#=ch#>Channels(ref Unsafe.Add(ref rsi, isx), cutmullCoeffs);
                    psx += acc;
                    isx += facc;
                    bool h = psx >= ram;
                    int y = Unsafe.As<bool, byte>(ref h);
                    isx += y;
                    psx -= -y & ram;
                }
                if (rec < 0)
                {
                    red = 1;
                    rec = 0;
                }
            }
            return (isx, psx, rec, red);
        }

<#}#>

        #endregion

        #region Direct
        private int ResampleDirect (Span<float> buffer, int channels, Span<float> srcBuffer) {
            int outputSamplePosition = 0;
            int inputSampleIndex = 0, cG = conversionGradient;
            int ram = RateMul;
            int acc = GradientIncrement;
            int facc = IndexIncrement;
            float rmi = RateMulInverse;
            if (channels == Vector<float>.Count) //SIMD Optimized Multi-Channel Audio Resampling
            {
                inputSampleIndex = ResampleDirectVectorFitStandard(buffer, srcBuffer, ref cG, ram, acc, facc, rmi);
            } else {
                switch (channels) {
                    case 1: //Monaural
                        inputSampleIndex = ResampleDirectMonauralStandard(buffer, srcBuffer, ref cG, ram, acc, facc, rmi);
                        break;

                        #region SIMD Optimized Multi-Channel Audio Resampling
<#foreach ((var ch, var type) in channelsAndTypes) {#>
                            case <#= ch#> :
                                inputSampleIndex = ResampleDirect<#=ch#>ChannelsStandard(buffer, srcBuffer, ref cG, ram, acc, facc, rmi);
                                break;
<#}#>

                        #endregion SIMD Optimized Multi-Channel Audio Resampling

                    default:
                        inputSampleIndex = ResampleDirectGeneric(buffer, srcBuffer, channels, ref cG, ram, acc, facc, rmi);
                        break;
                }
            }
            conversionGradient = cG;
            return inputSampleIndex;
        }

<#foreach ((var ch, var type) in channelsAndTypes) {#>
        [MethodImpl(OptimizationUtils.AggressiveOptimizationIfPossible)]
        private static int ResampleDirect<#=ch#>ChannelsStandard(Span<float> buffer, Span<float> srcBuffer, ref int x, int ram, int acc, int facc, float rmi)
        {
            nint isx = 0;
            nint psx = x;
            nint spsx = psx;
            nint nram = ram;
            nint nacc = acc;
            var vBuffer = Cast<float, <#= type#>>(buffer);
            var vSrcBuffer = Cast<float, <#= type#>>(srcBuffer);
            nint i = 0, length=vBuffer.Length;
            ref var rsi = ref GetReference(vSrcBuffer);
            ref var rdi = ref GetReference(vBuffer);
            Vector4 c0 = C0, c1 = C1, c2 = C2, c3 = C3;
            Vector4 x1 = default, x2 = default, x3 = default;
            Vector4 y0 = default, y1 = default, y2 = default;
            for (int j = 0; j < 4; j++)
            {
                var nx3 = new Vector4(spsx * rmi);
                spsx += acc;
                bool h2 = spsx >= nram;
                nint g2 = Unsafe.As<bool, byte>(ref h2);
                y0 = y1 * x1;
                y0 += c3;
                y1 = y2 * x2;
                y1 += c2;
                y2 = c0 * x3;
                y2 += c1;
                spsx -= -g2 & nram;
                x1 = x2;
                x2 = x3;
                x3 = nx3;
            }
            for (; i < length; i++)
            {
                psx += acc;
                bool h = psx >= nram;
                nint g = Unsafe.As<bool, byte>(ref h);
                Unsafe.Add(ref rdi, i) = VectorUtils.FastDotMultiple<#=ch#>Channels(ref Unsafe.Add(ref rsi, isx), y0);
                isx += g;
                isx += facc;
                var nx3 = new Vector4(spsx * rmi);
                spsx += acc;
                bool h2 = spsx >= nram;
                nint g2 = Unsafe.As<bool, byte>(ref h2);
                y0 = y1 * x1;
                y0 += c3;
                y1 = y2 * x2;
                y1 += c2;
                y2 = c0 * x3;
                y2 += c1;
                psx -= -g & nram;
                spsx -= -g2 & nram;
                x1 = x2;
                x2 = x3;
                x3 = nx3;
            }
            x = (int)psx;
            return (int)isx;
        }

<#}#>
        #endregion
    }
}
