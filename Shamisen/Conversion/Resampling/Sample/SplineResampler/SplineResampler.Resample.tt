<#@ template debug = "false" hostspecific = "false" language = "C#"#>
<#@ assembly name = "System.Core"#>
<#@ import namespace = "System.Linq"#>
<#@ import namespace = "System.Text"#>
<#@ import namespace = "System.Collections.Generic"#>
<#@ output extension = ".g.cs"#>
<#    var channelsAndTypes = new [] {(2, "Vector2"), (3, "Vector3"), (4, "Vector4")};#>
<#var attributes = new [] {(2, "Vector2", "Stereo"), (3, "Vector3", "Triple"), (4, "Vector4", "Quadruple")};#>
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Text;
using static System.Runtime.InteropServices.MemoryMarshal;
using System.Numerics;
using System.Runtime.CompilerServices;
using Shamisen.Filters;
using Shamisen.Formats;
using Shamisen.Utils;

namespace Shamisen.Conversion.Resampling.Sample
{
    public sealed partial class SplineResampler
    {
        private const int RemSampleOffset = 4;
        [MethodImpl(OptimizationUtils.InlineAndOptimizeIfPossible)]
        private int ResampleCachedDirect (Span<float> buffer, int channels, Span<float> srcBuffer) {
            ref var coeffPtr = ref GetReference (preCalculatedCatmullRomCoefficents.AsSpan ());
            int outputSamplePosition = 0;
            
            int inputSampleIndex = 0, x = conversionGradient;
            int ram = RateMul;
            int acc = GradientIncrement;
            int facc = IndexIncrement;
            if (channels == Vector<float>.Count) //SIMD Optimized Multi-Channel Audio Resampling
            {
                var vBuffer = Cast<float, Vector<float>> (buffer);
                var vSrcBuffer = Cast<float, Vector<float>> (srcBuffer);
                for (int i = 0; i < vBuffer.Length; i++) {
                    ref var values = ref Unsafe.As < Vector<float>,
                        (Vector<float> X, Vector<float> Y, Vector<float> Z, Vector<float> W) > (ref vSrcBuffer[inputSampleIndex]);
                    var cutmullCoeffs = Unsafe.Add (ref coeffPtr, x);
                    var value1 = values.X * cutmullCoeffs.X; //The control point 1.
                    var value2 = values.Y * cutmullCoeffs.Y; //The control point 2.
                    var value3 = values.Z * cutmullCoeffs.Z; //The control point 3.
                    var value4 = values.W * cutmullCoeffs.W; //The control point 4.
                    vBuffer[i] = value1 + value2 + value3 + value4;
                    x += acc;
                    inputSampleIndex += facc;
                    if (x >= ram)
                    {
                        x -= ram;
                        inputSampleIndex++;
                    }
                }
            } else {
                switch (channels) {
                    case 1: //Monaural
                        inputSampleIndex = ResampleCachedDirectMonaural(buffer, srcBuffer, ref coeffPtr, ref x, ram, acc, facc);
                        break;
                        #region SIMD Optimized Multi-Channel Audio Resampling
<#foreach ((var ch, var type) in channelsAndTypes) {#>
                    case <#= ch#>:
                        inputSampleIndex = ResampleCachedDirect<#=ch#>Channels(buffer, srcBuffer, ref coeffPtr, ref x, ram, acc, facc);
                        break;
<#}#>

                        #endregion SIMD Optimized Multi-Channel Audio Resampling

                    default:

                        #region Channels that is not SIMD optimized

                        {
                            unsafe {
                                fixed (float * srcBufPtr = srcBuffer) {
                                    for (int i = 0; i < buffer.Length - channels + 1; i += channels) {
                                        var cache = srcBufPtr + inputSampleIndex * channels;
                                        var cutmullCoeffs = Unsafe.Add (ref coeffPtr, x);
                                        for (int ch = 0; ch < channels; ch++) {
                                            ref var destSample = ref buffer[i + ch]; //Persist the reference in order to eliminate boundary checks.
                                            var values = new Vector4(
                                                cache[ch], cache[channels + ch], cache[channels * 2 + ch], cache[channels * 3 + ch]);
                                            
                                            destSample = VectorUtils.FastDotProduct(values, cutmullCoeffs);
                                        }
                                        x += acc;
                                        inputSampleIndex += facc;
                                        if (x >= ram)
                                        {
                                            x -= ram;
                                            inputSampleIndex++;
                                        }
                                        outputSamplePosition++;
                                    }
                                }
                            }
                        }

                        #endregion Channels that is not SIMD optimized

                        break;
                }
            }
            conversionGradient = x;
            return inputSampleIndex;
        }

<#foreach ((var ch, var type) in channelsAndTypes) {#>
        private static int ResampleCachedDirect<#=ch#>ChannelsStandard(Span<float> buffer, Span<float> srcBuffer, ref Vector4 coeffPtr, ref int x, int ram, int acc, int facc)
        {
            int isx = 0;
            int psx = x;
            ref var vBuffer = ref Unsafe.As<float, <#= type#>>(ref GetReference(buffer));
            ref var vSrcBuffer = ref Unsafe.As<float, <#= type#>>(ref GetReference(srcBuffer));
            nint i;
            nint length = buffer.Length / <#=ch#>;
            if (facc > 0)
            {
                for (i = 0; i < length; i++)
                {
                    var values = Unsafe.As <<#=type#>,
                        ( <#=type#> X, <#=type#> Y, <#=type#> Z, <#=type#> W) > (ref Unsafe.Add(ref vSrcBuffer, isx));
                    var cutmullCoeffs = Unsafe.Add (ref coeffPtr, psx);
                    var value1 = values.X * cutmullCoeffs.X; //The control point 1.
                    var value2 = values.Y * cutmullCoeffs.Y; //The control point 2.
                    var value3 = values.Z * cutmullCoeffs.Z; //The control point 3.
                    var value4 = values.W * cutmullCoeffs.W; //The control point 4.
                    Unsafe.Add(ref vBuffer, i) = value1 + value2 + value3 + value4;
                    psx += acc;
                    isx += facc;
                    if (psx >= ram)
                    {
                        psx -= ram;
                        isx++;
                    }
                }
            }
            else
            {
                var values = Unsafe.As <<#=type#>, (<#=type#> X, <#=type#> Y, <#=type#> Z, <#=type#> W)>(ref vSrcBuffer);
                for (i = 0; i < length; i++)
                {
                    var cutmullCoeffs = Unsafe.Add (ref coeffPtr, psx);
                    var value1 = values.X * cutmullCoeffs.X; //The control point 1.
                    var value2 = values.Y * cutmullCoeffs.Y; //The control point 2.
                    var value3 = values.Z * cutmullCoeffs.Z; //The control point 3.
                    var value4 = values.W * cutmullCoeffs.W; //The control point 4.
                    Unsafe.Add(ref vBuffer, i) = value1 + value2 + value3 + value4;
                    psx += acc;
                    if (psx >= ram)
                    {
                        psx -= ram;
                        isx++;
                        values = Unsafe.As <<#=type#>,
                        ( <#=type#> X, <#=type#> Y, <#=type#> Z, <#=type#> W) > (ref Unsafe.Add(ref vSrcBuffer, isx));
                    }
                }
            }
            x = psx;
            return isx;
        }

<#}#>
        private int ResampleCachedWrappedOdd (Span<float> buffer, int channels, Span<float> srcBuffer) {
            ref var coeffPtr = ref GetReference (preCalculatedCatmullRomCoefficents.AsSpan ());
            int outputSamplePosition = 0;
            
            Vector4 GetCatmullRomCoefficents (ref Vector4 coeffs, int i)
            {
                int x = i;
                if (i <= RateMul >> 1) return Unsafe.Add(ref coeffs, x);
                x = RateMul - i;
                var q = Unsafe.Add(ref coeffs, x);
                return VectorUtils.ReverseElements(q);
            }
            int inputSampleIndex = 0, x = conversionGradient;
            int ram = RateMul;
            int acc = GradientIncrement;
            int facc = IndexIncrement;
            if (channels == Vector<float>.Count) //SIMD Optimized Multi-Channel Audio Resampling
            {
                var vBuffer = Cast<float, Vector<float>> (buffer);
                var vSrcBuffer = Cast<float, Vector<float>> (srcBuffer);
                for (int i = 0; i < vBuffer.Length; i++) {
                    ref var values = ref Unsafe.As < Vector<float>,
                        (Vector<float> X, Vector<float> Y, Vector<float> Z, Vector<float> W) > (ref vSrcBuffer[inputSampleIndex]);
                    var cutmullCoeffs = GetCatmullRomCoefficents (ref coeffPtr, x);
                    var value1 = values.X * cutmullCoeffs.X; //The control point 1.
                    var value2 = values.Y * cutmullCoeffs.Y; //The control point 2.
                    var value3 = values.Z * cutmullCoeffs.Z; //The control point 3.
                    var value4 = values.W * cutmullCoeffs.W; //The control point 4.
                    vBuffer[i] = value1 + value2 + value3 + value4;
                    x += acc;
                    inputSampleIndex += facc;
                    if (x >= ram)
                    {
                        x -= ram;
                        inputSampleIndex++;
                    }
                }
            } else {
                switch (channels) {
                    case 1: //Monaural
                        for (int i = 0; i < buffer.Length; i++) {
                            var values = Unsafe.As<float, Vector4> (ref srcBuffer[inputSampleIndex]);
                            var cutmullCoeffs = GetCatmullRomCoefficents (ref coeffPtr, x);
                            buffer[i] = VectorUtils.FastDotProduct(values, cutmullCoeffs);
                            x += acc;
                            inputSampleIndex += facc;
                            if (x >= ram)
                            {
                                x -= ram;
                                inputSampleIndex++;
                            }
                        }
                        break;

                        #region SIMD Optimized Multi-Channel Audio Resampling
<#foreach ((var ch, var type) in channelsAndTypes) {#>
                            case <#= ch#> :
                                {
                                    var vBuffer = Cast < float,
                                        <#= type#>> (buffer);
                                    var vSrcBuffer = Cast < float,
                                        <#= type#>> (srcBuffer);
                                    for (int i = 0; i < vBuffer.Length; i++) {
                                        ref var values = ref Unsafe.As <<#=type#>,
                                            ( <#=type#> X, <#=type#> Y, <#=type#> Z, <#=type#> W) > (ref vSrcBuffer[inputSampleIndex]);
                                        var cutmullCoeffs = GetCatmullRomCoefficents (ref coeffPtr, x);
                                        var value1 = values.X * cutmullCoeffs.X; //The control point 1.
                                        var value2 = values.Y * cutmullCoeffs.Y; //The control point 2.
                                        var value3 = values.Z * cutmullCoeffs.Z; //The control point 3.
                                        var value4 = values.W * cutmullCoeffs.W; //The control point 4.
                                        vBuffer[i] = value1 + value2 + value3 + value4;
                                        x += acc;
                                        inputSampleIndex += facc;
                                        if (x >= ram)
                                        {
                                            x -= ram;
                                            inputSampleIndex++;
                                        }
                                    }
                                }
                                break;
<#}#>

                        #endregion SIMD Optimized Multi-Channel Audio Resampling

                    default:

                        #region Channels that is not SIMD optimized

                        {
                            unsafe {
                                fixed (float * srcBufPtr = srcBuffer) {
                                    for (int i = 0; i < buffer.Length - channels + 1; i += channels) {
                                        var cache = srcBufPtr + inputSampleIndex * channels;
                                        var cutmullCoeffs = GetCatmullRomCoefficents (ref coeffPtr, x);
                                        for (int ch = 0; ch < channels; ch++) {
                                            ref var destSample = ref buffer[i + ch]; //Persist the reference in order to eliminate boundary checks.
                                            var value1 = cache[ch] * cutmullCoeffs.X; //The control point 1.
                                            var value2 = cache[channels + ch] * cutmullCoeffs.Y; //The control point 2.
                                            var value3 = cache[channels * 2 + ch] * cutmullCoeffs.Z; //The control point 3.
                                            var value4 = cache[channels * 3 + ch] * cutmullCoeffs.W; //The control point 4.

                                            
                                            destSample = value1 + value2 + value3 + value4;
                                        }
                                        x += acc;
                                        inputSampleIndex += facc;
                                        if (x >= ram)
                                        {
                                            x -= ram;
                                            inputSampleIndex++;
                                        }
                                        outputSamplePosition++;
                                    }
                                }
                            }
                        }

                        #endregion Channels that is not SIMD optimized

                        break;
                }
            }
            conversionGradient = x;
            return inputSampleIndex;
        }
        private int ResampleCachedWrappedEven (Span<float> buffer, int channels, Span<float> srcBuffer) {
            ref var coeffPtr = ref GetReference (preCalculatedCatmullRomCoefficents.AsSpan ());
            int outputSamplePosition = 0;
            int rmul = RateMul;
            
            Vector4 GetCatmullRomCoefficents (ref Vector4 coeffs, int i)
            {
                int x = i;
                if (i < RateMul >> 1) return Unsafe.Add(ref coeffs, x);
                x = RateMul - i - 1;
                var q = Unsafe.Add(ref coeffs, x);
                return VectorUtils.ReverseElements(q);
            }
            int inputSampleIndex = 0, x = conversionGradient;
            int ram = RateMul;
            int acc = GradientIncrement;
            int facc = IndexIncrement;
            if (channels == Vector<float>.Count) //SIMD Optimized Multi-Channel Audio Resampling
            {
                var vBuffer = Cast<float, Vector<float>> (buffer);
                var vSrcBuffer = Cast<float, Vector<float>> (srcBuffer);
                for (int i = 0; i < vBuffer.Length; i++) {
                    ref var values = ref Unsafe.As < Vector<float>,
                        (Vector<float> X, Vector<float> Y, Vector<float> Z, Vector<float> W) > (ref vSrcBuffer[inputSampleIndex]);
                    var cutmullCoeffs = GetCatmullRomCoefficents (ref coeffPtr, x);
                    var value1 = values.X * cutmullCoeffs.X; //The control point 1.
                    var value2 = values.Y * cutmullCoeffs.Y; //The control point 2.
                    var value3 = values.Z * cutmullCoeffs.Z; //The control point 3.
                    var value4 = values.W * cutmullCoeffs.W; //The control point 4.

                    
                    vBuffer[i] = value1 + value2 + value3 + value4;
                    x += acc;
                    inputSampleIndex += facc;
                    if (x >= ram)
                    {
                        x -= ram;
                        inputSampleIndex++;
                    }
                }
            } else {
                switch (channels) {
                    case 1: //Monaural
                        for (int i = 0; i < buffer.Length; i++) {
                            var values = Unsafe.As<float, Vector4> (ref srcBuffer[inputSampleIndex]);
                            var cutmullCoeffs = GetCatmullRomCoefficents (ref coeffPtr, x);

                            
                            buffer[i] = VectorUtils.FastDotProduct(values, cutmullCoeffs);
                            x += acc;
                            inputSampleIndex += facc;
                            if (x >= ram)
                            {
                                x -= ram;
                                inputSampleIndex++;
                            }
                        }
                        break;

                        #region SIMD Optimized Multi-Channel Audio Resampling
<#foreach ((var ch, var type) in channelsAndTypes) {#>
                            case <#= ch#> :
                                {
                                    var vBuffer = Cast < float,
                                        <#= type#>> (buffer);
                                    var vSrcBuffer = Cast < float,
                                        <#= type#>> (srcBuffer);
                                    for (int i = 0; i < vBuffer.Length; i++) {
                                        ref var values = ref Unsafe.As <<#=type#>,
                                            ( <#=type#> X, <#=type#> Y, <#=type#> Z, <#=type#> W) > (ref vSrcBuffer[inputSampleIndex]);
                                        var cutmullCoeffs = GetCatmullRomCoefficents (ref coeffPtr, x);
                                        var value1 = values.X * cutmullCoeffs.X; //The control point 1.
                                        var value2 = values.Y * cutmullCoeffs.Y; //The control point 2.
                                        var value3 = values.Z * cutmullCoeffs.Z; //The control point 3.
                                        var value4 = values.W * cutmullCoeffs.W; //The control point 4.
                                        vBuffer[i] = value1 + value2 + value3 + value4;
                                        x += acc;
                                        inputSampleIndex += facc;
                                        if (x >= ram)
                                        {
                                            x -= ram;
                                            inputSampleIndex++;
                                        }
                                    }
                                }
                                break;
<#}#>

                        #endregion SIMD Optimized Multi-Channel Audio Resampling

                    default:

                        #region Channels that is not SIMD optimized

                        {
                            unsafe {
                                fixed (float * srcBufPtr = srcBuffer) {
                                    for (int i = 0; i < buffer.Length - channels + 1; i += channels) {
                                        var cache = srcBufPtr + inputSampleIndex * channels;
                                        var cutmullCoeffs = GetCatmullRomCoefficents (ref coeffPtr, x);
                                        for (int ch = 0; ch < channels; ch++) {
                                            ref var destSample = ref buffer[i + ch]; //Persist the reference in order to eliminate boundary checks.
                                            var value1 = cache[ch] * cutmullCoeffs.X; //The control point 1.
                                            var value2 = cache[channels + ch] * cutmullCoeffs.Y; //The control point 2.
                                            var value3 = cache[channels * 2 + ch] * cutmullCoeffs.Z; //The control point 3.
                                            var value4 = cache[channels * 3 + ch] * cutmullCoeffs.W; //The control point 4.

                                            
                                            destSample = value1 + value2 + value3 + value4;
                                        }
                                        x += acc;
                                        inputSampleIndex += facc;
                                        if (x >= ram)
                                        {
                                            x -= ram;
                                            inputSampleIndex++;
                                        }
                                        outputSamplePosition++;
                                    }
                                }
                            }
                        }

                        #endregion Channels that is not SIMD optimized

                        break;
                }
            }
            conversionGradient = x;
            return inputSampleIndex;
        }
        private int ResampleDirect (Span<float> buffer, int channels, Span<float> srcBuffer) {
            int outputSamplePosition = 0;
            var c0 = new Vector4(-0.5f, 1.5f, -1.5f, 0.5f);
            var c1 = new Vector4(1.0f, -2.5f, 2.0f, -0.5f);
            var c2 = new Vector4(-0.5f, 0.0f, 0.5f, 0.0f);
            var c3 = new Vector4(0.0f, 1.0f, 0.0f, 0.0f);
            int inputSampleIndex = 0, cG = conversionGradient;
            int ram = RateMul;
            int acc = GradientIncrement;
            int facc = IndexIncrement;
            if (channels == Vector<float>.Count) //SIMD Optimized Multi-Channel Audio Resampling
            {
                var vBuffer = Cast<float, Vector<float>> (buffer);
                var vSrcBuffer = Cast<float, Vector<float>> (srcBuffer);
                for (int i = 0; i < vBuffer.Length; i++) {
                    float x = cG * RateMulInverse;
                    float xP2 = x * x;
                    float xP3 = xP2 * x;
                    ref var values = ref Unsafe.As < Vector<float>,
                        (Vector<float> X, Vector<float> Y, Vector<float> Z, Vector<float> W) > (ref vSrcBuffer[inputSampleIndex]);
                    var value1 = values.X; //The control point 1.
                    var value2 = values.Y; //The control point 2.
                    var value3 = values.Z; //The control point 3.
                    var value4 = values.W; //The control point 4.

                    
                    vBuffer[i] = 0.5f * (
                        2.0f * value2 +
                        (-value1 + value3) * x +
                        (2.0f * value1 - 5.0f * value2 + 4.0f * value3 - value4) * xP2 +
                        (3.0f * value2 - value1 - 3.0f * value3 + value4) * xP3);
                    cG += acc;
                    inputSampleIndex += facc;
                    if (cG >= ram)
                    {
                        cG -= ram;
                        inputSampleIndex++;
                    }
                }
            } else {
                switch (channels) {
                    case 1: //Monaural
                        for (int i = 0; i < buffer.Length; i++) {
                            float x = cG * RateMulInverse;
                            var vx = new Vector4(x);
                            var y = vx * c0;
                            y += c1;
                            y *= vx;
                            y += c2;
                            y *= vx;
                            y += c3;
                            var values = Unsafe.As<float, Vector4> (ref srcBuffer[inputSampleIndex]);
                            buffer[i] = VectorUtils.FastDotProduct(values, y);
                            cG += acc;
                            inputSampleIndex += facc;
                            if (cG >= ram)
                            {
                                cG -= ram;
                                inputSampleIndex++;
                            }
                        }
                        break;

                        #region SIMD Optimized Multi-Channel Audio Resampling
<#foreach ((var ch, var type) in channelsAndTypes) {#>
                            case <#= ch#> :
                                {
                                    var vBuffer = Cast < float,
                                        <#= type#>> (buffer);
                                    var vSrcBuffer = Cast < float,
                                        <#= type#>> (srcBuffer);
                                    for (int i = 0; i < vBuffer.Length; i++) {
                                        float x = cG * RateMulInverse;
                                        var vx = new Vector4(x);
                                        var y = vx * c0;
                                        y += c1;
                                        y *= vx;
                                        y += c2;
                                        y *= vx;
                                        y += c3;
                                        ref var values = ref Unsafe.As <<#=type#>,
                                            ( <#=type#> X, <#=type#> Y, <#=type#> Z, <#=type#> W) > (ref vSrcBuffer[inputSampleIndex]);
                                        var value1 = values.X * y.X; //The control point 1.
                                        var value2 = values.Y * y.Y; //The control point 2.
                                        var value3 = values.Z * y.Z; //The control point 3.
                                        var value4 = values.W * y.W; //The control point 4.
                                        vBuffer[i] = value1 + value2 + value3 + value4;
                                        cG += acc;
                                        inputSampleIndex += facc;
                                        if (cG >= ram)
                                        {
                                            cG -= ram;
                                            inputSampleIndex++;
                                        }
                                    }
                                }
                                break;
<#}#>

                        #endregion SIMD Optimized Multi-Channel Audio Resampling

                    default:

                        #region Channels that is not SIMD optimized

                        {
                            unsafe {
                                fixed (float * srcBufPtr = srcBuffer) {
                                    for (int i = 0; i < buffer.Length; i += channels) {
                                        var cache = srcBufPtr + inputSampleIndex * channels;
                                        float x = cG * RateMulInverse;
                                        var vx = new Vector4(x);
                                        var y = vx * c0;
                                        y += c1;
                                        y *= vx;
                                        y += c2;
                                        y *= vx;
                                        y += c3;
                                        for (int ch = 0; ch < channels - channels + 1; ch++) {
                                            ref var destSample = ref buffer[i + ch]; //Persist the reference in order to reduce boundary checks.
                                            var values = new Vector4(
                                                cache[ch], cache[channels + ch], cache[channels * 2 + ch], cache[channels * 3 + ch]);
                                            
                                            destSample = VectorUtils.FastDotProduct(values, y);
                                        }
                                        cG += acc;
                                        inputSampleIndex += facc;
                                        if (cG >= ram)
                                        {
                                            cG -= ram;
                                            inputSampleIndex++;
                                        }
                                        outputSamplePosition++;
                                    }
                                }
                            }
                        }

                        #endregion Channels that is not SIMD optimized

                        break;
                }
            }
            conversionGradient = cG;
            return inputSampleIndex;
        }
    }
}
