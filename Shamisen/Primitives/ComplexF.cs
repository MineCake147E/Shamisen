using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace Shamisen.Primitives
{
    /// <summary>
    /// <see cref="Complex"/> like structure based on <see cref="float"/>
    /// </summary>
    public readonly partial struct ComplexF : IEquatable<ComplexF>, IFormattable
    {
        private readonly Vector2 value;

        //TODO: functions compatible to Complex

        /// <summary>
        /// Gets the real part of this instance.
        /// </summary>
        /// <value>
        /// The real part.
        /// </value>
        public float Real => value.X;

        /// <summary>
        /// Gets the imaginary part of this instance.
        /// </summary>
        /// <value>
        /// The imaginary part.
        /// </value>
        public float Imaginary => value.Y;

        /// <summary>
        /// Gets the magnitude of this instance.
        /// </summary>
        /// <value>
        /// The magnitude of this instance.
        /// </value>
        public float Magnitude => value.Length();

        /// <summary>
        /// Gets the phase of this instance.
        /// </summary>
        /// <value>
        /// The phase of this instance.
        /// </value>
        public float Phase => (float)Math.Atan2(value.Y, value.X);

        /// <summary>
        /// Initializes a new instance of the <see cref="ComplexF"/> struct.
        /// </summary>
        /// <param name="real">The real part.</param>
        /// <param name="imaginary">The imaginary part.</param>
        public ComplexF(float real, float imaginary)
        {
            value = new Vector2(real, imaginary);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ComplexF"/> struct.
        /// </summary>
        /// <param name="value">The value vector X=Real, Y=Imaginary.</param>
        public ComplexF(Vector2 value)
        {
            this.value = value;
        }

        #region Constants and read-only fields

        /// <summary>
        /// The inverse of ln(10)
        /// </summary>
        /// <autogeneratedoc />
        private const float InverseLog10 = 0.43429448190325f;

        /// <summary>
        /// Returns a new Complex instance with a real number equal to zero and an imaginary number equal to zero.
        /// </summary>
        public static ComplexF Zero => new ComplexF(0.0f, 0.0f);

        /// <summary>
        /// Returns a new Complex instance with a real number equal to one and an imaginary number equal to zero.
        /// </summary>
        public static ComplexF One => new ComplexF(1.0f, 0.0f);

        /// <summary>
        /// Returns a new Complex instance with a real number equal to zero and an imaginary number equal to one.
        /// </summary>
        public static ComplexF ImaginaryOne => new ComplexF(0.0f, 1.0f);

        #endregion Constants and read-only fields

        #region Unary Arithmetics

        /// <summary>
        /// Returns the additive inverse of a specified complex number.
        /// </summary>
        /// <param name="value">The value to negate.</param>
        /// <returns>
        /// The result of the <see cref="Real"/> and <see cref="Imaginary"/> components of the value parameter multiplied by -1.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF operator -(ComplexF value) => new ComplexF(-value.value);

        #endregion Unary Arithmetics

        #region Binary Arithmetics

        /// <summary>
        /// Subtracts a complex number from another complex number.
        /// </summary>
        /// <param name="left">The value to subtract from (the minuend).</param>
        /// <param name="right">The value to subtract (the subtrahend).</param>
        /// <returns>
        /// The result of subtracting <paramref name="right"/> from <paramref name="left"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF operator -(ComplexF left, ComplexF right) => new ComplexF(left.value - right.value);

        /// <summary>
        /// Adds two complex numbers.
        /// </summary>
        /// <param name="left">The first value to add.</param>
        /// <param name="right">The second value to add.</param>
        /// <returns>
        /// The sum of <paramref name="left"/> and <paramref name="right"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF operator +(ComplexF left, ComplexF right) => new ComplexF(left.value + right.value);

        /// <summary>
        /// Multiplies two specified complex numbers.
        /// </summary>
        /// <param name="left">The first value to multiply.</param>
        /// <param name="right">The second value to multiply.</param>
        /// <returns>
        /// The product of <paramref name="left"/> and <paramref name="right"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF operator *(ComplexF left, ComplexF right) => new ComplexF((left.Real * right.Real) - (left.Imaginary * right.Imaginary),
            (left.Real * right.Imaginary) + (left.Imaginary * right.Real));

        /// <summary>
        /// Multiplies specified complex number with specified real number.
        /// </summary>
        /// <param name="left">The first value to multiply.</param>
        /// <param name="right">The second value to multiply.</param>
        /// <returns>
        /// The product of <paramref name="left"/> and <paramref name="right"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF operator *(ComplexF left, float right) => new ComplexF(left.value * right);

        /// <summary>
        /// Divides a specified complex number by another specified complex number.
        /// </summary>
        /// <param name="left">The value to be divided.</param>
        /// <param name="right">The value to divide by.</param>
        /// <returns>
        /// The result of dividing <paramref name="left"/> by <paramref name="right"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF operator /(ComplexF left, ComplexF right)
        {
            var div = 1.0f / right.value.LengthSquared();
            return new ComplexF(div * ((left.Real * right.Real) + (left.Imaginary * right.Imaginary)),
                div * ((left.Imaginary * right.Real) - (left.Real * right.Imaginary)));
        }

        #endregion Binary Arithmetics

        #region Equality

        /// <summary>
        /// Indicates whether the values of two specified <see cref="ComplexF"/> objects are equal.
        /// </summary>
        /// <param name="complex1">The first <see cref="ComplexF"/> to compare.</param>
        /// <param name="complex2">The second <see cref="ComplexF"/> to compare.</param>
        /// <returns>
        ///   <c>true</c> if the value of complex1 is the same as the value of complex2; otherwise, <c>false</c>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(ComplexF complex1, ComplexF complex2) => complex1.value == complex2.value;

        /// <summary>
        /// Indicates whether the values of two specified <see cref="ComplexF"/> objects are not equal.
        /// </summary>
        /// <param name="complex1">The first <see cref="ComplexF"/> to compare.</param>
        /// <param name="complex2">The second <see cref="ComplexF"/> to compare.</param>
        /// <returns>
        ///   <c>true</c> if complex1 and complex2 are not equal; otherwise, <c>false</c>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(ComplexF complex1, ComplexF complex2) => !(complex1 == complex2);

        /// <summary>
        /// Determines whether the specified <see cref="object" />, is equal to this instance.
        /// </summary>
        /// <param name="obj">The <see cref="object" /> to compare with this instance.</param>
        /// <returns>
        ///   <c>true</c> if the specified <see cref="object" /> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj) => obj is ComplexF complex && value.Equals(complex.value);

        /// <summary>
        /// Returns a hash code for this instance.
        /// </summary>
        /// <returns>
        /// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode() => -1584136870 + value.GetHashCode();

        /// <summary>
        /// Indicates whether the current object is equal to another object of the same type.
        /// </summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        /// true if the current object is equal to the <paramref name="other">other</paramref> parameter; otherwise, false.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(ComplexF other) => this == other;

        #endregion Equality

        #region Formattablity

        /// <summary>
        /// Converts this instance to string.
        /// </summary>
        /// <param name="format">The format.</param>
        /// <param name="formatProvider">The format provider.</param>
        /// <returns>
        /// A <see cref="string" /> that represents this instance.
        /// </returns>
        public string ToString(string? format, IFormatProvider? formatProvider) => value.ToString(format, formatProvider);

        #endregion Formattablity

        #region Implicit Conversions

        /// <summary>
        /// Performs an implicit conversion from <see cref="ComplexF"/> to <see cref="Complex"/>.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Complex(ComplexF value) => new Complex(value.Real, value.Imaginary);

        /// <summary>
        /// Performs an implicit conversion from <see cref="float"/> to <see cref="ComplexF"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ComplexF(float value) => new ComplexF(value, 0);

        #endregion Implicit Conversions

        #region Explicit Conversions

        /// <summary>
        /// Performs an explicit conversion from <see cref="Complex"/> to <see cref="ComplexF"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator ComplexF(Complex value) => new ComplexF((float)value.Real, (float)value.Imaginary);

        #endregion Explicit Conversions

        #region Functions

        /// <summary>
        /// Gets the absolute value (or magnitude) of a complex number.
        /// </summary>
        /// <param name="value">A complex number.</param>
        /// <returns>The absolute value of <paramref name="value"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Abs(ComplexF value) => value.value.Length();

        /// <summary>
        /// Computes the conjugate of a complex number and returns the result.
        /// </summary>
        /// <param name="value">A complex number.</param>
        /// <returns>The conjugate of <paramref name="value"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF Conjugate(ComplexF value) => new ComplexF(value.Real, -value.Imaginary);

        /// <summary>
        /// Returns the multiplicative inverse of a complex number.
        /// </summary>
        /// <param name="value">A complex number.</param>
        /// <returns>The reciprocal of <paramref name="value"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF Reciprocal(ComplexF value) => value.Real == 0 && value.Imaginary == 0 ? Zero : One / value;

        /// <summary>
        /// Adds two complex numbers and returns the result.
        /// </summary>
        /// <param name="left">The first value to add.</param>
        /// <param name="right">The second value to add.</param>
        /// <returns>
        /// The sum of <paramref name="left"/> and <paramref name="right"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF Add(ComplexF left, ComplexF right) => left + right;

        /// <summary>
        /// Subtracts a complex number from another complex number and returns the result.
        /// </summary>
        /// <param name="left">The value to subtract from (the minuend).</param>
        /// <param name="right">The value to subtract (the subtrahend).</param>
        /// <returns>
        /// The result of subtracting <paramref name="right"/> from <paramref name="left"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF Subtract(ComplexF left, ComplexF right) => left - right;

        /// <summary>
        /// Multiplies two specified complex numbers.
        /// </summary>
        /// <param name="left">The first value to multiply.</param>
        /// <param name="right">The second value to multiply.</param>
        /// <returns>
        /// The product of <paramref name="left"/> and <paramref name="right"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF Multiply(ComplexF left, ComplexF right) => left * right;

        /// <summary>
        /// Divides a specified complex number by another specified complex number.
        /// </summary>
        /// <param name="left">The value to be divided.</param>
        /// <param name="right">The value to divide by.</param>
        /// <returns>
        /// The result of dividing <paramref name="left"/> by <paramref name="right"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF Divide(ComplexF left, ComplexF right) => left / right;

        /// <summary>
        /// Returns the additive inverse of a specified complex number.
        /// </summary>
        /// <param name="value">The value to negate.</param>
        /// <returns>
        /// The result of the <see cref="Real"/> and <see cref="Imaginary"/> components of the value parameter multiplied by -1.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF Negate(ComplexF value) => -value;

        /// <summary>
        /// Creates a complex number from a point's polar coordinates.
        /// </summary>
        /// <param name="magnitude">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</param>
        /// <param name="phase">The phase, which is the angle from the line to the horizontal axis, measured in radians.</param>
        /// <returns>A complex number.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF FromPolarCoordinates(double magnitude, double phase) => (ComplexF)Complex.FromPolarCoordinates(magnitude, phase);

        /// <summary>
        /// Creates a complex number from a point's polar coordinates.
        /// </summary>
        /// <param name="magnitude">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</param>
        /// <param name="phase">The phase, which is the angle from the line to the horizontal axis, measured in radians.</param>
        /// <returns>A complex number.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF FromPolarCoordinates(float magnitude, float phase) => (ComplexF)Complex.FromPolarCoordinates(magnitude, phase);

        /// <summary>
        /// Returns the square root of a specified complex number.
        /// </summary>
        /// <param name="value">A complex number.</param>
        /// <returns>The square root of <paramref name="value"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ComplexF Sqrt(ComplexF value) => (ComplexF)Complex.Sqrt(value);

        #endregion Functions
    }
}
