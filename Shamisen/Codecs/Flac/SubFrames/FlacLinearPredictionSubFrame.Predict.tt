<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var c = Enumerable.Range(1, 32);
    var intrinsicsArmed = Enumerable.Range(2, 31).ToHashSet();
    var intrinsicsArmedWide = Enumerable.Range(2, 31).ToHashSet();
    var enregisterPrevious = new HashSet<int>(){1};
    var enregisterCoeffs = new HashSet<int>(){1, 2, 3, 4, 5, 6, 7, 8};
    var names = c.Select(f=>(Order: f, intrinsicsArmed:intrinsicsArmed.Contains(f), enregisterPrevious: enregisterPrevious.Contains(f), intrinsicsArmedWide: intrinsicsArmedWide.Contains(f),
    enregisterCoeffs: enregisterCoeffs.Contains(f)));
    const string Suffix = "Standard";
 #>
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

using Shamisen.Codecs.Flac.Parsing;

namespace Shamisen.Codecs.Flac.SubFrames
{
    public sealed partial class FlacLinearPredictionSubFrame
    {
        [MethodImpl(OptimizationUtils.InlineAndOptimizeIfPossible)]
        internal static unsafe void RestoreSignalStandard(int shiftsNeeded, ReadOnlySpan<int> residual, ReadOnlySpan<int> coeffs, Span<int> output)
        {
            var order = coeffs.Length;
            switch (order)
            {
<#    foreach(var item in names){#>
                case <#=            item.Order#>:
<#        if(item.intrinsicsArmed){ #>
                    if(<#=                $"RestoreSignalOrder{item.Order}Intrinsic"#>(shiftsNeeded, residual, coeffs, output)) return;
<#        } #>
                    <#=            $"RestoreSignalOrder{item.Order}{Suffix}"#>(shiftsNeeded, residual, coeffs, output);
                    return;
<#    }#>
                default:
                    throw new FlacException("Invalid FLAC stream!");
            }
        }

<#    foreach(var item in names){#>
        [MethodImpl(OptimizationUtils.InlineAndOptimizeIfPossible)]
        internal static unsafe void <#=            $"RestoreSignalOrder{item.Order}{Suffix}"#>(int shiftsNeeded, ReadOnlySpan<int> residual, ReadOnlySpan<int> coeffs, Span<int> output)
        {
            const int Order = <#=            item.Order#>;
            if(coeffs.Length < Order) return;
            _ = coeffs[Order - 1];
<#        if(item.enregisterPrevious){
            for(int i = 0; i < item.Order; i++){
                Write($"\t\t\tvar prev{i} = output[{i}];\r\n");
            }
        }
        if(item.enregisterCoeffs){
            for(int i = 0; i < item.Order; i++){
                Write($"\t\t\tvar coeff{i} = coeffs[{i}];\r\n");
            }
        }
        else
        {#>
            ref var c = ref MemoryMarshal.GetReference(coeffs);
<#        }
#>
            int sum;
            ref var o = ref MemoryMarshal.GetReference(output);
            ref var d = ref Unsafe.Add(ref o, Order);
            int dataLength = output.Length - Order;
            ref var r = ref MemoryMarshal.GetReference(residual);
            for(int i = 0; i < dataLength; i++)
            {
                sum = 0;
<#        if(item.enregisterPrevious){
            for(int i = item.Order - 1; i > 0; i--){
                Write($"\t\t\t\tsum += coeff{i} * prev{item.Order - i - 1};\r\n\t\t\t\tprev{item.Order - 1 - i} = prev{item.Order - i};\r\n");
            }
            Write($"\t\t\t\tsum += coeff0 * prev{item.Order - 1};\r\n");
        }
        else if(item.enregisterCoeffs)
        {
            for(int i = item.Order - 1; i > 0; i--){
                Write($"\t\t\t\tsum += coeff{i} * Unsafe.Add(ref o, i + {item.Order - 1 - i});\r\n");
            }
            Write($"\t\t\t\tsum += coeff0 * Unsafe.Add(ref o, i + {item.Order - 1});\r\n");
        }
        else
        {
            for(int i = item.Order - 1; i > 0; i--){
                Write($"\t\t\t\tsum += Unsafe.Add(ref c, {i}) * Unsafe.Add(ref o, i + {item.Order - i - 1});\r\n");
            }
            Write($"\t\t\t\tsum += c * Unsafe.Add(ref o, i + {item.Order - 1});\r\n");
        }
#>
                sum >>= shiftsNeeded;
                sum += Unsafe.Add(ref r, i);
                Unsafe.Add(ref d, i) = sum;
<#        if(item.enregisterPrevious){#>
                prev<#=                item.Order - 1 #> = sum;
<#        }#>
            }
        }
<#    } #>
        [MethodImpl(OptimizationUtils.InlineAndOptimizeIfPossible)]
        internal static unsafe void RestoreSignalStandardWide(int shiftsNeeded, ReadOnlySpan<int> residual, ReadOnlySpan<int> coeffs, Span<int> output)
        {
            var order = coeffs.Length;
            switch (order)
            {
<#    foreach(var item in names){#>
                case <#=            item.Order#>:
<#        if(item.intrinsicsArmedWide){ #>
                    if(<#=                $"RestoreSignalOrder{item.Order}WideIntrinsic"#>(shiftsNeeded, residual, coeffs, output)) return;
<#        } #>
                    <#=            $"RestoreSignalOrder{item.Order}Wide{Suffix}"#>(shiftsNeeded, residual, coeffs, output);
                    return;
<#    }#>
                default:
                    throw new FlacException("Invalid FLAC stream!");
            }
        }

<#    foreach(var item in names){#>
        [MethodImpl(OptimizationUtils.InlineAndOptimizeIfPossible)]
        internal static unsafe void <#=            $"RestoreSignalOrder{item.Order}Wide{Suffix}"#>(int shiftsNeeded, ReadOnlySpan<int> residual, ReadOnlySpan<int> coeffs, Span<int> output)
        {
            const int Order = <#=            item.Order#>;
            if(coeffs.Length < Order) return;
            _ = coeffs[Order - 1];
<#        if(item.enregisterPrevious){
            for(int i = 0; i < item.Order; i++){
                Write($"\t\t\tvar prev{i} = output[{i}];\r\n");
            }
        }
        if(item.enregisterCoeffs){
            for(int i = 0; i < item.Order; i++){
                Write($"\t\t\tlong coeff{i} = coeffs[{i}];\r\n");
            }
        }
        else
        {#>
            ref var c = ref MemoryMarshal.GetReference(coeffs);
<#        }
#>
            long sum;
            ref var o = ref MemoryMarshal.GetReference(output);
            ref var d = ref Unsafe.Add(ref o, Order);
            int dataLength = output.Length - Order;
            ref var r = ref MemoryMarshal.GetReference(residual);
            for(int i = 0; i < dataLength; i++)
            {
                sum = 0;
<#        if(item.enregisterPrevious){
            for(int i = item.Order - 1; i > 0; i--){
                Write($"\t\t\t\tsum += coeff{i} * prev{item.Order - i - 1};\r\n\t\t\t\tprev{item.Order - 1 - i} = prev{item.Order - i};\r\n");
            }
            Write($"\t\t\t\tsum += coeff0 * prev{item.Order - 1};\r\n");
        }
        else if(item.enregisterCoeffs)
        {
            for(int i = item.Order - 1; i > 0; i--){
                Write($"\t\t\t\tsum += coeff{i} * Unsafe.Add(ref o, i + {item.Order - 1 - i});\r\n");
            }
            Write($"\t\t\t\tsum += coeff0 * Unsafe.Add(ref o, i + {item.Order - 1});\r\n");
        }
        else
        {
            for(int i = item.Order - 1; i > 0; i--){
                Write($"\t\t\t\tsum += Unsafe.Add(ref c, {i}) * (long)Unsafe.Add(ref o, i + {item.Order - i - 1});\r\n");
            }
            Write($"\t\t\t\tsum += c * (long)Unsafe.Add(ref o, i + {item.Order - 1});\r\n");
        }
#>
                sum >>= shiftsNeeded;
                sum += Unsafe.Add(ref r, i);
                Unsafe.Add(ref d, i) = (int)sum;
<#        if(item.enregisterPrevious){#>
                prev<#=                item.Order - 1 #> = (int)sum;
<#        }#>
            }
        }
<#    } #>
    }
}
